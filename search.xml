<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>读写锁的实现</title>
    <url>/2020/09/29/%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>读写锁就是对于临界区区分读和写。在读多写少的场景下，不加区分的使用互斥量显然是浪费的，这时读写锁就派上用场了。</p>
<p>读写锁的特性：</p>
<ul>
<li>当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会阻塞</li>
<li>当读写锁被加了读锁时，其他线程对该锁加写锁会阻塞，加读锁会成功</li>
</ul>
<p>因而适用于多读少写的场景</p>
<p><strong><code>RWlock.h</code></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWLock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RWLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~RWLock() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read_lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read_unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    condition_variable read_cv;</span><br><span class="line">    condition_variable write_cv;</span><br><span class="line">    atomic&lt;<span class="keyword">int</span>&gt; read_count; <span class="comment">//已经加上读锁的线程的数量</span></span><br><span class="line">    atomic&lt;<span class="keyword">int</span>&gt; write_count; <span class="comment">//等待加上写锁的线程的数量</span></span><br><span class="line">    atomic&lt;<span class="keyword">bool</span>&gt; is_writing; <span class="comment">//记录当前是否有线程加了写锁</span></span><br><span class="line">    mutex mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong><code>RWlock.cpp</code></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RWLock.h"</span></span></span><br><span class="line"></span><br><span class="line">RWLock::RWLock() :</span><br><span class="line">        read_count(<span class="number">0</span>),</span><br><span class="line">        write_count(<span class="number">0</span>),</span><br><span class="line">        is_writing(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RWLock::read_lock() &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; guard(mutex_);</span><br><span class="line">    <span class="comment">//只有当前没有等待加写锁的线程时，才加读锁</span></span><br><span class="line">    read_cv.wait(guard, [=] &#123; <span class="keyword">return</span> write_count == <span class="number">0</span>; &#125;);</span><br><span class="line">    ++read_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RWLock::read_unlock() &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; guard(mutex_);</span><br><span class="line">    --read_count;</span><br><span class="line">    <span class="keyword">if</span> (read_count == <span class="number">0</span> &amp;&amp; write_count &gt; <span class="number">0</span>)</span><br><span class="line">        write_cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RWLock::write_lock() &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; guard(mutex_);</span><br><span class="line">    <span class="comment">//记录等待加写锁的数量</span></span><br><span class="line">    ++write_count;</span><br><span class="line">    write_cv.wait(guard, [=] &#123; <span class="keyword">return</span> read_count == <span class="number">0</span> &amp;&amp; !is_writing; &#125;);</span><br><span class="line">    is_writing = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RWLock::write_unlock() &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; guard(mutex_);</span><br><span class="line">    write_count--;</span><br><span class="line">    <span class="comment">//写优先，有等待加写锁的先加写锁，否则才加读锁</span></span><br><span class="line">    <span class="keyword">if</span> (write_count == <span class="number">0</span>) &#123;</span><br><span class="line">        read_cv.notify_all();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write_cv.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





























]]></content>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
        <tag>读写锁</tag>
      </tags>
  </entry>
  <entry>
    <title>指针、数组和函数</title>
    <url>/2020/09/21/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>数组指针和指针数组</strong></p>
<p><strong>数组指针</strong></p>
<p>定义 int (*p)[n];</p>
<p>()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度</p>
<p>如要将二维数组赋给一指针，应这样赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>]; <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组。</span></span><br><span class="line">p=a;        <span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span></span><br><span class="line">p++;       <span class="comment">//该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span></span><br></pre></td></tr></table></figure>

<p><strong>指针数组</strong></p>
<p>定义 int *p[n];</p>
<p>[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值</p>
<p>如要将二维数组赋给一指针数组:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	p[i]=a[i];</span><br></pre></td></tr></table></figure>

<p>这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]，所以要分别赋值</p>
<p><strong>指针数组和数组指针的内存布局</strong></p>
<img src="/2020/09/21/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/22201218-19ddd896ae6a45e1b61c7e3ee59b4662.jpg" alt="img" style="zoom: 80%;">

<hr>
<p><strong>函数指针和指针函数</strong></p>
<p><strong>指针函数</strong></p>
<p>指针函数，简单的来说，就是一个<strong>返回指针</strong>的函数，其本质是一个函数，而该函数的返回值是一个指针。<br>声明格式为：<strong>类型标识符 *函数名(参数表)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        sum = a + b;</span><br><span class="line">        <span class="keyword">return</span> &amp;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">        p=add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add result is %d\n"</span>, *p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数指针</strong></p>
<p>函数指针，其本质是一个<strong>指针变量</strong>，该<strong>指针指向这个函数</strong>。总结来说，函数指针就是指向函数的指针。<br>声明格式：类型说明符  (*函数名)  (参数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br></pre></td></tr></table></figure>

<p>函数指针是需要把一个函数的地址赋值给它，有两种写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure>

<p>调用函数指针的方式也有两种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        p=add;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add result is %d\n"</span>, p(<span class="number">200</span>,<span class="number">300</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>一种string类的简单实现</title>
    <url>/2020/01/20/%E4%B8%80%E7%A7%8Dstring%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>C++中String类的简单实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    myString(<span class="keyword">const</span> <span class="keyword">char</span> *str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *data = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    myString(<span class="keyword">const</span> myString &amp;str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    myString(myString&amp;&amp; str):data(str.data)&#123;</span><br><span class="line">        str.data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">    myString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> myString &amp;str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">    myString&amp; <span class="keyword">operator</span>=(myString&amp;&amp; str)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = str.data;</span><br><span class="line">        str.data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~myString()&#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">String</span> s0; <span class="comment">//构造</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>; <span class="comment">//构造</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">s2</span><span class="params">(s0)</span></span>;</span><br><span class="line">    <span class="keyword">String</span> s3 = s1;</span><br><span class="line">    s2 = s1;</span><br><span class="line"></span><br><span class="line">    foo(s1);</span><br><span class="line">    bar(s1);</span><br><span class="line">    foo(<span class="string">"temporary"</span>);</span><br><span class="line">    bar(<span class="string">"temporary"</span>);</span><br><span class="line">    <span class="keyword">String</span> s4 = baz();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">String</span>&gt; svec;</span><br><span class="line">    svec.push_back(s0);</span><br><span class="line">    svec.push_back(s1);</span><br><span class="line">    svec.push_back(baz());</span><br><span class="line">    svec.push_back(<span class="string">"good job"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝赋值</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">移动构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">移动构造</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确地删除vector中符合条件的某元素</title>
    <url>/2019/11/20/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%88%A0%E9%99%A4vector%E4%B8%AD%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9F%90%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>比如，有一个vector&lt; int &gt; nums = {1, 2, 2, 2, 2, 3, 5}，要求删除nums中所有值为2的元素 </p>
<h3 id="一个符合直觉的错误实现"><a href="#一个符合直觉的错误实现" class="headerlink" title="一个符合直觉的错误实现"></a>一个符合直觉的错误实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123; </span><br><span class="line">        nums.erase(it); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码循环遍历nums中的每个元素，判断是否为2，是的话则erase掉。看起来好像没什么问题，但是实际上已经造成了bug。这段代码的执行完成后，<strong>nums存储的元素是{1, 2, 2, 3, 5}</strong>，值为2的元素并没有被全部清除掉。</p>
<p>为什么会出现这个结果呢？原因就是<strong>迭代器失效</strong> ：在第一个2被erase掉的时候，it迭代器已经失效了，它指向了被删除元素的下一个元素，用它来继续遍历vector就会漏掉被删除元素后面的第一个元素，导致2没有被完全清除。</p>
<h3 id="第一种正确实现：让it指向下一个元素"><a href="#第一种正确实现：让it指向下一个元素" class="headerlink" title="第一种正确实现：让it指向下一个元素"></a>第一种正确实现：让it指向下一个元素</h3><p><strong>erase函数的返回值是指向当前被删除元素的下一个元素的迭代器</strong>。那么我们把这个返回值赋值给it继续遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">        it = nums.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种正确实现：erase-remove"><a href="#第二种正确实现：erase-remove" class="headerlink" title="第二种正确实现：erase-remove"></a>第二种正确实现：erase-remove</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    nums.erase(<span class="built_in">remove</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(), <span class="number">2</span>), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>erase</strong>用来删除一段区间的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>remove</strong>  <strong>移除但不删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它<strong>并不真正从容器中删除那些元素</strong>（换句话说容器的大小不变），<strong>而是将每一个不与value相等（也就是我们不打算移除）的元素轮番赋值给first之后的空间</strong>。</p>
<p>例如：{0，1，0，2，0，3，0，4}，用remove移除值为0的元素，执行结果为{1，2，3，4，0，3，0，4}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>) &#123;</span></span><br><span class="line">    first = <span class="built_in">find</span>(first, last, value);</span><br><span class="line">    ForwardIterator next = first;</span><br><span class="line">    <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> remove_copy(++next, last, first, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove_copy</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">IntputIt</span> <span class="title">first</span>,<span class="title">IntputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它并不真正从容器中删除那些元素（换句话说容器的大小不变）,而是<strong>将结果复制到一个以result标示起始位置的容器上，新容器可以和原容器重叠。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">OutputIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIt</span> <span class="title">remove_copy</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first!=last;++first)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*first!=value)&#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









































]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C库函数memcpy()和memmove()的区别</title>
    <url>/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>memcpy( )和memmove( )都是C语言中的库函数，在头文件string.h中。</p>
<p>其作用是从src内存中拷贝n个字节到dest内存区域中，原型分别如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="memcpy-和memmove-的区别"><a href="#memcpy-和memmove-的区别" class="headerlink" title="memcpy()和memmove()的区别"></a>memcpy()和memmove()的区别</h3><p>他们的作用是一样的，<strong>唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。</strong></p>
<p><img src="/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/memory.png" alt="memory"></p>
<h3 id="memcpy-函数的实现"><a href="#memcpy-函数的实现" class="headerlink" title="memcpy()函数的实现"></a>memcpy()函数的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    <span class="keyword">char</span> *s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        *tmp++ = *s_src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="memmove-实现函数"><a href="#memmove-实现函数" class="headerlink" title="memmove()实现函数"></a>memmove()实现函数</h3><p>memmove就是针对第二种内存覆盖情形，对memcpy进行了改进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memmove</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s_dst;</span><br><span class="line">    <span class="keyword">char</span>* s_src;</span><br><span class="line">    s_dst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">if</span>(s_dst&gt;s_src &amp;&amp; (s_src+n&gt;s_dst)) &#123;      <span class="comment">//第二种内存覆盖的情形。</span></span><br><span class="line">        <span class="comment">// 从后往前复制，防止出现内存覆盖的情形</span></span><br><span class="line">        s_dst = s_dst+n<span class="number">-1</span>;</span><br><span class="line">        s_src = s_src+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst-- = *s_src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst++ = *s_src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
