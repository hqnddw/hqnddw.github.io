<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单例模式</title>
    <url>/2020/10/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
<p>实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p>
<p>单例模式有两种实现方法，分别是懒汉和饿汉模式。顾名思义，懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；饿汉模式，即迫不及待，在程序运行时立即初始化。</p>
<h3 id="经典的线程安全懒汉模式"><a href="#经典的线程安全懒汉模式" class="headerlink" title="经典的线程安全懒汉模式"></a><strong>经典的线程安全懒汉模式</strong></h3><p>单例模式的实现思路如前述所示，其中，经典的线程安全懒汉模式，<strong>使用双检测锁模式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> single *p;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex <span class="keyword">mutex_t</span>;</span><br><span class="line"></span><br><span class="line">    single() &#123;&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> single *<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">mutex_t</span>);</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                p = <span class="keyword">new</span> single;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    ~single()&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single *single::p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex single::<span class="keyword">mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    single *s1 = single::getInstance();</span><br><span class="line">    single *s2 = single::getInstance();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>为什么要用双检测，只检测一次不行吗？</code></strong></p>
<p>如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。</p>
<hr>
<h3 id="局部静态变量之线程安全懒汉模式"><a href="#局部静态变量之线程安全懒汉模式" class="headerlink" title="局部静态变量之线程安全懒汉模式"></a><strong>局部静态变量之线程安全懒汉模式</strong></h3><p>前面的双检测锁模式，写起来不太优雅，《Effective C++》（Item 04）中的提出另一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">single</span>&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     single()&#123;&#125;</span><br><span class="line">     ~single()&#123;&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">single* single::getinstance()&#123;</span><br><span class="line">    <span class="keyword">static</span> single obj;</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，C++0X以后，要求编译器保证内部静态变量的线程安全性，故C++0x之后该实现是线程安全的，C++0x之前仍需加锁，其中C++0x是C++11标准成为正式标准之前的草案临时名字。</p>
<hr>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a><strong>饿汉模式</strong></h3><p>饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> single *p;</span><br><span class="line">    single() &#123;&#125;</span><br><span class="line">    ~single() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> single *<span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single *single::p = <span class="keyword">new</span> single();</span><br><span class="line">single *single::getinstance() &#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    single *p1 = single::getinstance();</span><br><span class="line">    single *p2 = single::getinstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"same"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么MySQL会抖一下</title>
    <url>/2020/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<p>平时的工作中，一条SQL语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。看上去，这就像是数据库“抖”了一下</p>
<p>InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作redo log（重做日志），在更新内存写完redo log后，就返回给客户端，本次更新成功。而InnoDB总要把内存里的数据写入磁盘，术语就是flush，即把内存中的脏页flush到磁盘上使之变成干净页。</p>
<p>平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）</p>
<p><strong>什么情况会引发数据库的flush过程？</strong></p>
<p><strong>第一种场景是InnoDB的redo log写满了</strong>。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写</p>
<img src="/2020/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/image-20200716150914770.png" alt="image-20200716150914770" style="zoom:40%;">

<p><strong>第二种场景是系统内存不足</strong>。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</p>
<p><strong>第三种场景是MySQL认为系统“空闲”的时候</strong>。当然，MySQL“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”</p>
<p><strong>第四种场景是MySQL正常关闭的情况</strong>。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p>
<p>刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p>
<ol>
<li><p>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</p>
</li>
<li><p>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</p>
<p><strong>InnoDB刷脏页速度策略</strong></p>
</li>
</ol>
<p>InnoDB的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是redo log写盘速度。</p>
<p>F1计算方法：参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字</p>
<p>F2计算方法：InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字</p>
<img src="/2020/10/07/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B/Users/hqnddw/Desktop/md文件/数据库.assets/image-20200716151702090.png" alt="image-20200716151702090" style="zoom:40%;">

<p>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p>
<p>在InnoDB中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p>
<p>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>order by是怎么工作的</title>
    <url>/2020/10/07/order%20by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<p>假设你要查询城市是“杭州”的所有人名字，并且按照<strong>姓名排序</strong>返回前1000个人的姓名、年龄。</p>
<p>假设这个表的部分定义是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>这时，你的SQL语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>下面讲解这个语句的执行流程。</p>
<p><strong>全字段排序</strong></p>
<p>为避免全表扫描，我们需要在city字段加上索引</p>
<img src="/2020/10/07/order%20by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/Users/hqnddw/Desktop/md文件/数据库.assets/image-20200716172934243.png" alt="image-20200716172934243" style="zoom:40%;">

<p>从图中可以看到，满足city=’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。</p>
<p>通常情况下，这个语句执行流程如下所示 ：</p>
<ol>
<li>初始化<strong>sort_buffer</strong>，确定放入name、city、age这三个字段；</li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id，也就是图中的ID_X；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name做快速排序；</li>
<li>按照排序结果取前1000行返回给客户端。</li>
</ol>
<p>我们暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示</p>
<img src="/2020/10/07/order%20by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/Users/hqnddw/Desktop/md文件/数据库.assets/image-20200716173046109.png" alt="image-20200716173046109" style="zoom: 45%;">

<p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size。</p>
<p>sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>
<p><strong>rowid排序</strong></p>
<p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>
<p>max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法</p>
<p>新的算法放入sort_buffer的字段，只有要<strong>排序的列（即name字段</strong>）和<strong>主键id</strong>。</p>
<p>但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p>
<ol>
<li>初始化sort_buffer，确定放入两个字段，即name和id；</li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id，也就是图中的ID_X；</li>
<li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到不满足city=’杭州’条件为止，也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name进行排序；</li>
<li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li>
</ol>
<p>这个执行流程的示意图如下，我把它称为rowid排序。</p>
<img src="/2020/10/07/order%20by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/Users/hqnddw/Desktop/md文件/数据库.assets/image-20200716173352103.png" alt="image-20200716173352103" style="zoom:45%;">

<p>rowid排序多访问了一次表t的主键索引，就是步骤7。需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p>
<p><strong>全字段排序 VS rowid排序</strong></p>
<p>如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p>
<p>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p>
<p>这也就体现了MySQL的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>
<p>对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。</p>
<p><strong>其实，并不是所有的order by语句，都需要排序操作的。</strong>你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，是不是就可以不用再排序了呢？</p>
<p>所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>

<p>作为与city索引的对比，我们来看看这个索引的示意图。</p>
<img src="/2020/10/07/order%20by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/Users/hqnddw/Desktop/md文件/数据库.assets/image-20200716173702334.png" alt="image-20200716173702334" style="zoom:45%;">

<p>这样整个查询过程的流程就变成了：</p>
<ol>
<li>从索引(city,name)找到第一个满足city=’杭州’条件的主键id；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引(city,name)取下一个记录主键id；</li>
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city=’杭州’条件时循环结束</li>
</ol>
<p><strong>这个语句的执行流程有没有可能进一步简化呢？</strong></p>
<p><strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong>按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。</p>
<p>针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</span><br></pre></td></tr></table></figure>

<p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也就不再需要排序了。这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引(city,name,age)找到第一个满足city=’杭州’条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li>
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city=’杭州’条件时循环结束。</li>
</ol>
<hr>
<ol>
<li>无条件查询如果只有order by create_time,<strong>即便create_time上有索引,也不会使用到。</strong><br>因为优化器认为走二级索引再去回表成本比全表扫描排序更高。所以选择走全表扫描,</li>
<li>无条件查询但是是order by create_time limit m.<strong>如果m值较小,是可以走索引的.</strong><br>因为优化器认为根据索引有序性去回表查数据，然后得到m条数据,就可以终止循环，那么成本比全表扫描小，则选择走二级索引。即便没有二级索引，<strong>mysql针对order by limit也做了优化，采用堆排序</strong></li>
<li>如果是group by a，a上不能使用索引的情况，是走rowid排序。</li>
<li>如果是group by limit，不能使用索引的情况，是走堆排序</li>
<li>select * from t group by a –走的是索引全扫描</li>
<li>select a from t group by a –走的是索引松散扫描，也就说只需要扫描每组的第一行数据即可，不用扫描每一行的值</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>count()的实现方式</title>
    <url>/2020/10/07/count()%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在不同的MySQL引擎中，count(*)有不同的实现方式：</p>
<ul>
<li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li>
<li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<p><strong>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</strong></p>
<p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。</p>
<img src="/2020/10/07/count()%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/image-20200716155204142.png" alt="image-20200716155204142" style="zoom:45%;">

<p>MySQL在执行count(<em>)操作的时候还是做了优化的，它会找到最小的那棵索引树来遍历。*</em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一**</p>
<p><strong>show table status</strong> 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个<strong>TABLE_ROWS</strong>能代替count(*)吗？</p>
<p>实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到40%到50%。<strong>所以，show table status命令显示的行数也不能直接使用。</strong></p>
<p><strong>总结：</strong></p>
<ul>
<li>MyISAM表虽然count(*)很快，但是不支持事务；</li>
<li>show table status命令虽然返回很快，但是不准确；</li>
<li>InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>
<hr>
<p><strong>如果你现在有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？</strong></p>
<p>答案是，我们只能自己计数。</p>
<ol>
<li><p><strong>用缓存系统保存计数</strong>，你可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。</p>
<p><strong>存在的问题</strong>：</p>
<ul>
<li><p>缓存系统可能会丢失更新。试想如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后你要从存储redis数据的地方把这个值读回来，而刚刚加1的这个计数操作却丢失了。当然了，这还是有解的。比如，Redis异常重启以后，到数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里就可以了。</p>
</li>
<li><p>计数不精确的问题。我们是这么定义不精确的：</p>
<ol>
<li>一种是，查到的100行结果里面有最新插入记录，而Redis的计数里还没加1；</li>
<li>另一种是，查到的100行结果里没有最新插入的记录，而Redis的计数里已经加了1。</li>
</ol>
<img src="/2020/10/07/count()%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/image-20200716160337166.png" alt="image-20200716160337166" style="zoom:45%;">
</li>
</ul>
</li>
<li><p><strong>在数据库保存计数</strong></p>
</li>
</ol>
<p><strong>我们可以把这个计数直接放到数据库里单独的一张计数表C中</strong>，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。</p>
<p>同时我们可以利用“事务”这个特性，解决掉计数不精确的问题</p>
<img src="/2020/10/07/count()%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/image-20200716160658533.png" alt="image-20200716160658533" style="zoom:40%;">

<p>我们来看下现在的执行结果。虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p>
<p>因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>fork, vfork, 写时复制</title>
    <url>/2020/10/07/fork,%20vfork,%20%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork调用一次，返回两次，子进程的返回值为0，父进程的返回值为子进程的pid</p>
<p>子进程是父进程的副本。子进程获得父进程<strong>数据空间、堆和栈</strong>的<strong>副本</strong>。注意，这是子进程所拥有的的副本，父进程和子进程并不共享这些存储空间部分。父进程和子进程<strong>共享正文段</strong>。（fork也会复制父进程缓冲区的数据到子进程的缓冲区。父进程和子进程每个相同的打开文件描述符共享同一文件表项，父进程和子进程也共享同一文件的偏移量）</p>
<img src="/2020/10/07/fork,%20vfork,%20%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/image-20200728013407086.png" alt="image-20200728013407086" style="zoom:45%;">

<p><strong>fork出错的原因：</strong></p>
<ul>
<li>当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。</li>
<li>系统内存不足，这时errno的值被设置为ENOMEM。</li>
</ul>
<h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟空间结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间</p>
<img src="/2020/10/07/fork,%20vfork,%20%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/image-20200728013607556.png" alt="image-20200728013607556" style="zoom:45%;">

<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a><strong>vfork()</strong></h3><p>内核连子进程的虚拟地址空间结构也不创建了，直接共享了父进程的虚拟空间，当然了，这种做法就顺水推舟的共享了父进程的物理空间</p>
<img src="/2020/10/07/fork,%20vfork,%20%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/image-20200728013657849.png" alt="image-20200728013657849" style="zoom:45%;">

<p>fork和vfork的区别：</p>
<ul>
<li>fork ()：子进程拷贝父进程的数据段，代码段 ；vfork ()：子进程与父进程共享数据段 </li>
<li>fork ()：父子进程的执行次序不确定；vfork 保证子进程先运行，在它调用exec或exit 之后父进程才可能被调度运行。 如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。 </li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>fork</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis过期键删除策略</title>
    <url>/2020/10/06/%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h3 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h3><ol>
<li><p><strong>定时删除</strong>：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即删除对键的删除操作</p>
<p>主动删除，对内存友好，对cpu不友好</p>
</li>
<li><p><strong>惰性删除</strong>：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键。如果没有过期，就返回该键</p>
<p>被动删除，对cpu友好，对内存不友好</p>
</li>
<li><p><strong>定期删除</strong>：是前两种删除策略的一种折中。会每隔一段时间执行一次删除过期键操作，并通过限制操作执行的时长和频率来减少删除操作对cpu时间的影响</p>
<p>难点是确定删除策略的时长和频率</p>
</li>
</ol>
<h3 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h3><p>Redis服务器实际使用的是<strong>惰性删除和定期删除</strong>两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>
<h4 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h4><p>过期键的惰性删除策略由<code>db.c/expireIfNeeded</code>函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p>
<ul>
<li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li>
<li>如果输入键未过期，那么expireIfNeeded函数不做动作</li>
</ul>
<img src="/2020/10/06/%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/4633437-bc63f95d1c8b6114.png" alt="img" style="zoom:90%;">

<h4 id="定期删除键的策略实现"><a href="#定期删除键的策略实现" class="headerlink" title="定期删除键的策略实现"></a>定期删除键的策略实现</h4><p>过期键的定期删除策略由 <code>redis.c/activeExpireCycle</code>函数实现，每当 Redis 的服务器周期性操作 <code>redis.c/serverCron</code> 函数执行时， activeExpireCycle 函数就会被调用，它在规定的时间内分多次遍历服务器的各个数据库，检查数据库的 expires 字典中部分键(相当于分页查询)的过期时间，并删除它。步骤如下：</p>
<ol>
<li>函数每次运行时，都从一定数量的数据库取出一定数量的随机键进行检查，并删除其中的过期键。</li>
<li>全局变量 current_db 会记录当前 activeExpireCycle 函数的检查进度，并在下一次 activeExpireCycle 调用时，接着上一次的进度进行处理。</li>
<li>随着 activeExpireCycle 函数的不断执行，服务器中的所有数据库都会被检查一遍，当到达最后时，把 current_db 设置为 0，然后又重新开始，如此循环下去。</li>
</ol>
<hr>
<h3 id="RDB、AOF和复制功能对过期键的处理"><a href="#RDB、AOF和复制功能对过期键的处理" class="headerlink" title="RDB、AOF和复制功能对过期键的处理"></a>RDB、AOF和复制功能对过期键的处理</h3><h4 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h4><p>在执行SAVE命令和BGSAVE命令创建一个RDB文件时，程序会对数据库中的键进行检查，已过期的键不会保存到新创建的RDB文件中</p>
<h4 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h4><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入</p>
<ul>
<li>如果<strong>服务器以主服务器模式</strong>运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，<strong>未过期的键会被载入到数据库中，而过期键则会被忽略</strong>，所以过期键对载入RDB文 件的主服务器不会造成影响</li>
<li>如果<strong>服务器以从服务器模式</strong>运行，那么在载入RDB文件时，文件中保存的所有键，<strong>不论是否过期，都会被载入到数据库中</strong></li>
</ul>
<hr>
<h4 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h4><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么<strong>AOF文件不会因为这个过期键而产生任何影响</strong></p>
<p>当过期键被惰性删除或者定期删除之后，程序会<strong>向AOF文件追加（append）一条DEL命令</strong>，来显式地记录该键已被删除</p>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查， <strong>已过期的键不会被保存到重写后的AOF文件中</strong></p>
<hr>
<h4 id="复制与过期键的关系"><a href="#复制与过期键的关系" class="headerlink" title="复制与过期键的关系"></a>复制与过期键的关系</h4><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制:</p>
<ul>
<li>主服务器在删除一个过期键之后，会<strong>显式地向所有从服务器发送一个DEL命令</strong>，告知从服务器删除这个过期键</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键</li>
<li>从服务器<strong>只有在接到主服务器发来的DEL命令之后</strong>，才会删除过期键</li>
</ul>
<p>通过由主服务器来控制从服务器统一地删除过期键，可以<strong>保证主从服务器数据的一致性</strong></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录</title>
    <url>/2020/10/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h3 id="为什么需要单点登录"><a href="#为什么需要单点登录" class="headerlink" title="为什么需要单点登录"></a><strong>为什么需要单点登录</strong></h3><p>单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。</p>
<p>单点登录在大型网站里使用得非常频繁，例如，阿里旗下有淘宝、天猫、支付宝等网站，还有背后的成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。</p>
<p>所以，单点登录要解决的就是，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<img src="/2020/10/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/image-20201006195210043.png" alt="image-20201006195210043" style="zoom:67%;">

<p>如图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（SSO）的定义</p>
<h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><p>在说单点登录（SSO）的技术实现之前，我们先说一说普通的登录认证机制</p>
<img src="/2020/10/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/image-20201006195250896.png" alt="image-20201006195250896" style="zoom:67%;">

<p>如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。</p>
<h3 id="同域下的单点登录"><a href="#同域下的单点登录" class="headerlink" title="同域下的单点登录"></a>同域下的单点登录</h3><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。</p>
<p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p>
<ul>
<li>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</li>
<li>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的</li>
</ul>
<img src="/2020/10/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/image-20201006195410484.png" alt="image-20201006195410484" style="zoom:67%;">

<p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。<strong>我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie</strong></p>
<p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。</p>
<p>同域下的单点登录就实现了，<strong>但这还不是真正的单点登录</strong></p>
<h3 id="不同域下的单点登录"><a href="#不同域下的单点登录" class="headerlink" title="不同域下的单点登录"></a>不同域下的单点登录</h3><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明</p>
<p><img src="/2020/10/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/797930-20161203152650974-276822362.png" alt="img"></p>
<p>下面对上图简要描述</p>
<ol>
<li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户未登录，将用户引导至登录页面</li>
<li>用户输入用户名密码提交登录申请</li>
<li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为<strong>全局会话</strong>，同时创建<strong>授权令牌</strong></li>
<li>sso认证中心带着令牌跳转会最初的请求地址（系统1）</li>
<li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统1</li>
<li>系统1使用该令牌创建与用户的会话，称为<strong>局部会话</strong>，返回受保护资源</li>
<li>用户访问系统2的受保护资源</li>
<li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li>
<li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统2</li>
<li>系统2使用该令牌创建与用户的局部会话，返回受保护资源</li>
</ol>
<p>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系</p>
<ol>
<li>局部会话存在，全局会话一定存在</li>
<li>全局会话存在，局部会话不一定存在</li>
<li>全局会话销毁，局部会话必须销毁</li>
</ol>
<h4 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h4><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明</p>
<p><img src="/2020/10/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/797930-20161129155243068-1378377736.png" alt="3b139d2e-0b83-4a69-b4f2-316adb8997ce"></p>
<p>sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p>
<p>下面对上图简要说明</p>
<ol>
<li>用户向系统1发起注销请求</li>
<li>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求</li>
<li>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li>
<li>sso认证中心向所有注册系统发起注销请求</li>
<li>各注册系统接收sso认证中心的注销请求，销毁局部会话</li>
<li>sso认证中心引导用户至登录页面</li>
</ol>
]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP1.1、HTTP2、HTTP3演变</title>
    <url>/2020/10/06/HTTP1.1%E3%80%81HTTP2%E3%80%81HTTP3%E6%BC%94%E5%8F%98/</url>
    <content><![CDATA[<h3 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能" class="headerlink" title="HTTP/1.1 相比 HTTP/1.0 提高了什么性能"></a><strong>HTTP/1.1 相比 HTTP/1.0 提高了什么性能</strong></h3><p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：</p>
<ul>
<li><p>使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销</p>
<p>早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p>
<p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<p><strong>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</strong></p>
<p><strong>（字段connection：closed）</strong></p>
<p><img src="/2020/10/06/HTTP1.1%E3%80%81HTTP2%E3%80%81HTTP3%E6%BC%94%E5%8F%98/image-20200622165503037.png" alt="image-20200622165503037"></p>
</li>
<li><p>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p>
</li>
</ul>
<p>但 HTTP/1.1 还是有性能瓶颈：</p>
<ul>
<li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩<code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<h3 id="相比于HTTP-1-1，HTTP-2-做了什么优化"><a href="#相比于HTTP-1-1，HTTP-2-做了什么优化" class="headerlink" title="相比于HTTP/1.1，HTTP/2 做了什么优化"></a><strong>相比于HTTP/1.1，HTTP/2 做了什么优化</strong></h3><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p>
<p>HTTP/2 相比 HTTP/1.1 性能上的改进：</p>
<p><em>1. 头部压缩</em></p>
<p>HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引</p>
<p><em>2. 二进制格式</em></p>
<p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式。</strong></p>
<p>头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧和数据帧</strong>。那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p>
<p><img src="/2020/10/06/HTTP1.1%E3%80%81HTTP2%E3%80%81HTTP3%E6%BC%94%E5%8F%98/image-20200622155219851.png" alt="image-20200622155219851"></p>
<p><em>3. 数据流</em></p>
<p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>每个请求或回应的所有数据包，称为一个数据流（<code>Stream</code>）。</p>
<p>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p>
<p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p>
<p><img src="/2020/10/06/HTTP1.1%E3%80%81HTTP2%E3%80%81HTTP3%E6%BC%94%E5%8F%98/image-20200622155509121.png" alt="image-20200622155509121"></p>
<p><em>4. 多路复用</em></p>
<p>HTTP/2 是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p>
<p>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</p>
<p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p>
<p><em>5. 服务器推送</em></p>
<p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p>
<p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送（Server Push，也叫 Cache Push）。</p>
<p><strong>HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</strong></p>
<p>HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</p>
<p>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<ul>
<li>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li>
<li>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li>
</ul>
<h3 id="HTTP-3-把-HTTP-下层的-TCP-协议改成了-UDP"><a href="#HTTP-3-把-HTTP-下层的-TCP-协议改成了-UDP" class="headerlink" title="HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP"></a><strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</strong></h3><img src="/2020/10/06/HTTP1.1%E3%80%81HTTP2%E3%80%81HTTP3%E6%BC%94%E5%8F%98/Users/hqnddw/Desktop/md文件/webserver.assets/image-20200622160327666.png" alt="image-20200622160327666" style="zoom:80%;">

<p>UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。</p>
<p>大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<ul>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li>
<li>TLS 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code>。</li>
<li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 <code>TLS/1.3</code>的三次握手。QUIC 直接把以往的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong>。</li>
</ul>
<p><img src="/2020/10/06/HTTP1.1%E3%80%81HTTP2%E3%80%81HTTP3%E6%BC%94%E5%8F%98/image-20200622160538604.png" alt="image-20200622160538604"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>计算机网络网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之多态</title>
    <url>/2020/10/06/C++%E4%B9%8B%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>多态，即多种状态（形态）。简单的来说，我们可以将多态定义为消息以多种形式显示的能力。<strong><strong>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性</strong></strong>。用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”</p>
<h3 id="C-多态分类及实现"><a href="#C-多态分类及实现" class="headerlink" title="C++ 多态分类及实现"></a>C++ 多态分类及实现</h3><img src="/2020/10/06/C++%E4%B9%8B%E5%A4%9A%E6%80%81/inheritance.png" alt="img" style="zoom: 80%;">



<ul>
<li><p>应用形式上：静多态是发散式的，让相同的实现代码应用于不同的场合。动多态是收敛式的，让不同的实现代码应用于相同的场合。</p>
</li>
<li><p>思维方式上：静多态是泛型式编程风格，它看重的是算法的普适性；动多态是对象式编程风格，它看重的是接口和实现的分离度。</p>
</li>
</ul>
<h3 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a><strong>静态多态</strong></h3><p>静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;  <span class="comment">//函数重载的返回值可以不同</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h3><img src="/2020/10/06/C++%E4%B9%8B%E5%A4%9A%E6%80%81/image-20201006193658514.png" alt="image-20201006193658514" style="zoom:80%;">

<p>动态多态是在<strong>程序运行时</strong>根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                     // 形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态多态的条件：</strong></p>
<ul>
<li>基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行<strong>重写</strong>。</li>
<li>通过基类对象的指针或者引用调用虚函数。</li>
</ul>
<p><strong>多态有什么好处</strong></p>
<ol>
<li>应用程序不必为每一个派生类编写功能调用，只需要对抽象基类进行重写即可。提高程序的<strong>可复用性</strong></li>
<li>派生类的功能可以被基类对象的指针或引用所调用，提高了<strong>可扩充性</strong>和<strong>可维护性</strong></li>
</ol>
<p><strong>虚函数</strong></p>
<ul>
<li><p>如果在基类中定义了虚函数，派生类中的同名函数将自动变为虚函数</p>
</li>
<li><p>如果派生类中重新定义了基类中的虚函数，这样程序就会根据对象类型而不是引用或指针的类型来选择方法</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>普通函数（非类成员函数）不能是虚函数</p>
</li>
<li><p>静态成员函数不可以是虚函数。虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual.</p>
<p><strong>虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function</strong></p>
</li>
<li><p>构造函数无法是虚函数，因为调用虚函数需要虚函数表指针，而在执行构造函数之前是没有虚函数表指针的。</p>
</li>
<li><p>内联函数是在编译阶段进行展开，inline关键字作为提示符告诉编译器此函数作为内联函数希望在编译阶段展开，但是，编译器并不一定要展开。所以可以声明为<strong>inline虚析构函数</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象</strong>。</p>
<p><strong>基类的析构函数为什么要是虚函数？</strong></p>
<p>原因：<strong>防止在析构时只析构基类而不析构派生类</strong>。如果以一个基类指针指向其派生类，删除这个基类指针只能删除基类对象部分，而不能删除派生类对象，原因是通过基类指针无法访问派生类的析构函数。但是，如果像其它虚函数一样，基类的析构函数也是虚的，那么派生类的析构函数也必然是虚的，删除基类指针时，它就会通过虚函数表找到正确的派生类析构函数并调用它，从而正确析构整个派生类对象。</p>
<p><strong>为什么C++默认的析构函数不是虚函数</strong></p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数</p>
<p><strong>纯虚函数</strong></p>
<p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<p>作用：为了实现一个接口，起到一个规范的作用，规定继承这个类的子类必须实现这个函数，否则不能实例化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>虚函数、纯虚函数</strong></p>
<ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类</li>
</ul>
<p><strong>虚函数指针、虚函数表</strong></p>
<ul>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段（<code>.rodata section</code>），存放虚函数地址，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数地址</li>
</ul>
<p><strong>派生类虚表：</strong></p>
<ol>
<li>先将基类的虚表中的内容拷贝一份</li>
<li>如果派生类对基类中的虚函数进行重写，使用派生类的虚函数替换相同偏移量位置的基类虚函数</li>
<li>如果派生类中新增加自己的虚函数，按照其在派生类中的声明次序，放在上述虚函数之后</li>
</ol>
<p><strong>多重继承</strong></p>
<p><strong>当一个类继承多个类，且多个基类都有虚函数时，子类对象中将包含多个虚函数表的指针</strong></p>
<img src="/2020/10/06/C++%E4%B9%8B%E5%A4%9A%E6%80%81/Users/hqnddw/Desktop/md文件/c++面试点.assets/898333-20160609110953746-1340412428.png" alt="img" style="zoom:99%;">

<ul>
<li>A和B都没有基类，但是都有虚函数，因此各有一个虚函数指针</li>
<li>C同时继承了A和B，因此会继承两个虚函数指针，但是为了节省空间，C会与主基类A公用一个虚函数指针（即上图中vptr1），继承自B的虚函数指针假设为vptr2。</li>
<li>C没有重写继承自A和B的虚函数，因此在C的虚函数表中存在A::foo和B::bar函数指针（如果C中重写了foo()，则C的虚函数表中A::foo会被替换为C::foo）。</li>
<li>C中有两个虚函数指针vptr1和vptr2，相当于有两张虚函数表</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>重载、重写（覆盖）、隐藏的定义与区别</title>
    <url>/2020/10/06/%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%89%E3%80%81%E9%9A%90%E8%97%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h3><p>重载的定义为：<strong>在同一作用域中，同名函数的形式参数（参数个数、类型或者顺序）不同时，构成函数重载</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> 	<span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> 	<span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> 	<span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>;    	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> 	<span class="title">func</span><span class="params">(<span class="keyword">char</span>* pstr, <span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<ol>
<li><strong>函数返回值类型与构成重载无任何关系</strong></li>
<li><strong>类的静态成员函数与普通成员函数可以形成重载</strong></li>
<li><strong>函数重载发生在同一作用域，如类成员函数之间的重载、全局函数之间的重载</strong></li>
</ol>
<h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><p>隐藏定义：<strong>指不同作用域中定义的同名函数构成隐藏（不要求函数返回值和函数参数类型相同）</strong>。比如派生类成员函数隐藏与其同名的基类成员函数、类成员函数隐藏全局外部函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hidefunc</span><span class="params">(<span class="keyword">char</span>* pstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"global function: "</span> &lt;&lt; pstr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HideA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">hidefunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"HideA function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">usehidefunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//隐藏外部函数hidefunc，使用外部函数时要加作用域</span></span><br><span class="line">		hidefunc();</span><br><span class="line">		::hidefunc(<span class="string">"lvlv"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HideB</span> :</span> <span class="keyword">public</span> HideA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">hidefunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"HideB function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">usehidefunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//隐藏基类函数hidefunc，使用外部函数时要加作用域</span></span><br><span class="line">		hidefunc();</span><br><span class="line">		HideA::hidefunc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>隐藏的实质是；<strong>在函数查找时，名字查找先于类型检查</strong>。如果派生类中成员和基类中的成员同名，就隐藏掉。<strong>编译器首先在相应作用域中查找函数，如果找到名字一样的则停止查找</strong></p>
<h3 id="重写-覆盖"><a href="#重写-覆盖" class="headerlink" title="重写/覆盖"></a>重写/覆盖</h3><p>重写的定义：<strong>派生类中与基类同返回值类型、同名和同参数的虚函数重定义，构成虚函数覆盖，也叫虚函数重写</strong>。定义是：<strong>如果虚函数返回指针或者引用时（不包括value语义），子类中重写的函数返回的指针或者引用是父类中被重写函数所返回指针或引用的子类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A&amp; <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"In Base"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">new</span> A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">//返回值协变，构成虚函数重写</span></span><br><span class="line">     <span class="function">B&amp; <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"In Derived"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">new</span> B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比覆盖和隐藏，不难发现<strong>函数覆盖其实是函数隐藏的特例</strong>。如果派生类中定义了一个与基类虚函数同名但是参数列表不同的非virtual函数，则此函数是一个普通成员函数，并形成对基类中同名虚函数的隐藏，而非虚函数覆盖</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>函数重载发生在相同作用域</strong></li>
<li><strong>函数隐藏发生在不同作用域</strong></li>
<li><strong>函数覆盖就是函数重写。准确地叫做虚函数覆盖和虚函数重写，也是函数隐藏的特例</strong></li>
</ol>
<p>关于三者的对比，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">作用域</th>
<th align="center">有无virtual</th>
<th align="center">函数名</th>
<th align="center">形参列表</th>
<th align="center">返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">重载</td>
<td align="center">相同</td>
<td align="center">可有可无</td>
<td align="center">相同</td>
<td align="center">不同</td>
<td align="center">可同可不同</td>
</tr>
<tr>
<td align="center">隐藏</td>
<td align="center">不同</td>
<td align="center">可有可无</td>
<td align="center">相同</td>
<td align="center">可同可不同</td>
<td align="center">可同可不同</td>
</tr>
<tr>
<td align="center">重写</td>
<td align="center">不同</td>
<td align="center">有</td>
<td align="center">相同</td>
<td align="center">相同</td>
<td align="center">相同</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>短链接设计</title>
    <url>/2020/10/06/%E7%9F%AD%E9%93%BE%E6%8E%A5%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="短链接设计"><a href="#短链接设计" class="headerlink" title="短链接设计"></a>短链接设计</h3><p>短链优点：</p>
<ol>
<li>链接变短，在对内容长度有限制的平台发文，可编辑的文字就变多了</li>
<li>链接太长在有些平台上无法自动识别为超链接</li>
</ol>
<p><strong>短链跳转的基本原理</strong></p>
<p><img src="/2020/10/06/%E7%9F%AD%E9%93%BE%E6%8E%A5%E8%AE%BE%E8%AE%A1/v2-de770bb9a1036b55464b8d6acd8b0546_r.jpg" alt="preview"></p>
<ul>
<li>将长链接通过一定的<code>手段</code>生成一个短链接</li>
<li>访问短链接时实际访问的是<strong>短链接服务器</strong>，然后根据短链接的参数<strong>找回</strong>对应的长链接</li>
<li>重定向跳转</li>
</ul>
<p>301 和 302 都是重定向，到底该用哪个，这里需要注意一下 301 和 302 的区别</p>
<ul>
<li>301，代表 <strong>永久重定向</strong>，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301。</li>
<li><strong>302</strong>，代表 <strong>临时重定向</strong>，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存）,这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302！</li>
</ul>
<p><strong>短链生成的几种方法</strong></p>
<ol>
<li><strong>自增序列算法</strong></li>
</ol>
<p>我们可以维护一个 ID 自增生成器，比如 1，2，3 这样的整数递增 ID，当收到一个长链转短链的请求时，ID 生成器为其分配一个 ID，再将其转化为 62 进制（62进制转换是因为62进制转换后<strong>只含</strong>数字+小写+大写字母。而64进制转换会含有<code>/</code>,<code>+</code>这样的符号），拼接到短链域名后面就得到了最终的短网址，ID 自增生成器可以使用Mysql 自增主键</p>
<img src="/2020/10/06/%E7%9F%AD%E9%93%BE%E6%8E%A5%E8%AE%BE%E8%AE%A1/image-20200815192150490.png" alt="image-20200815192150490" style="zoom:50%;">

<ol start="2">
<li><strong>哈希算法</strong></li>
</ol>
<p>怎样才能生成短链，仔细观察上例中的短链，显然它是由固定短链域名 + 长链映射成的一串字母组成，可以用哈希函数将长链映射成一串字母，于是我们有了以下设计思路</p>
<p><img src="/2020/10/06/%E7%9F%AD%E9%93%BE%E6%8E%A5%E8%AE%BE%E8%AE%A1/image-20200815192323517.png" alt="image-20200815192323517"></p>
<p>那么这个哈希函数该怎么取呢，相信肯定有很多人说用 MD5，SHA 等算法，其实这样做有点杀鸡用牛刀了，而且既然是加密就意味着性能上会有损失，我们<strong>其实不关心反向解密的难度，反而更关心的是哈希的运算速度和冲突概率</strong></p>
<p>能够满足这样的哈希算法有很多，这里推荐 Google 出品的 MurmurHash 算法，MurmurHash 是一种<strong>非加密型</strong>哈希函数，适用于一般的哈希检索操作。与其它流行的哈希函数相比，对于规律性较强的 key，MurmurHash 的随机分布特征表现更良好。非加密意味着着相比 MD5，SHA 这些函数它的性能肯定更高</p>
<p>MurmurHash 提供了两种长度的哈希值，32 bit，128 bit，为了让网址尽可通地短，我们选择 32 bit 的哈希值，32 bit 能表示的最大值近 43 亿，对于中小型公司的业务而言绰绰有余。对上文提到的极客长链做 MurmurHash 计算，得到的哈希值为 3002604296，于是我们现在得到的短链为 固定短链域名+哈希值 = <a href="http://gk.link/a/3002604296" target="_blank" rel="noopener">http://gk.link/a/3002604296</a></p>
<p><strong>如何缩短域名？</strong></p>
<p>有人说人这个域名还是有点长，还有一招，3002604296 得到的这个哈希值是十进制的，那我们把它转为 62 进制可缩短它的长度，10 进制转 62 进制如下：</p>
<p><strong>如何解决哈希冲突的问题？</strong></p>
<p>我们知道既然访问访问短链能跳转到长链，那么两者之前这种映射关系一定是要保存起来的，可以用 Redis 或 Mysql 等，这里我们选择用 Mysql 来存储</p>
<p>于是我们有了以下设计思路。</p>
<ol>
<li>将长链（lurl）经过 MurmurHash 后得到短链。</li>
<li>再根据短链去 short_url_map 表中查找看是否存在相关记录，如果不存在，将长链与短链对应关系插入数据库中，存储。</li>
<li>如果存在，说明已经有相关记录了，此时在长串上拼接一个自定义好的字段，比如「DUPLICATE」，然后再对接接的字段串「lurl + DUPLICATE」做第一步操作，如果最后还是重复呢，再拼一个字段串啊，只要到时根据短链取出长链的时候把这些自定义好的字符串移除即是原来的长链。</li>
</ol>
<p>以上步骤显然是要优化的，插入一条记录居然要经过两次 sql 查询（根据短链查记录，将长短链对应关系插入数据库中），如果在高并发下，显然会成为瓶颈。</p>
<p>所以该怎么优化呢</p>
<ol>
<li>首先我们需要<strong>给短链字段 surl 加上唯一索引</strong></li>
<li>当长链经过 MurmurHash 得到短链后，直接将长短链对应关系插入 db 中，如果 db 里不含有此短链的记录，则插入，如果包含了，说明违反了唯一性索引，此时只要给长链再加上我们上文说的自定义字段「DUPLICATE」,重新 hash 再插入即可，看起来在违反唯一性索引的情况下是多执行了步骤，但我们要知道 MurmurHash 发生冲突的概率是非常低的，基本上不太可能发生，所以这种方案是可以接受的。</li>
</ol>
<p>当然如果在数据量很大的情况下，冲突的概率会增大，此时我们可以加<strong>布隆过滤器来进行优化</strong>。</p>
<p>用所有生成的短网址构建布隆过滤器，当一个新的长链生成短链后，先将此短链在布隆过滤器中进行查找，如果不存在，说明 db 里不存在此短网址，可以插入！</p>
<p>综上，如果用哈希函数来设计，总体的设计思路如下：</p>
<img src="/2020/10/06/%E7%9F%AD%E9%93%BE%E6%8E%A5%E8%AE%BE%E8%AE%A1/image-20200815192849526.png" alt="image-20200815192849526" style="zoom: 80%;">]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>短链接</tag>
      </tags>
  </entry>
  <entry>
    <title>右值引用、移动语义和完美转发</title>
    <url>/2020/10/06/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h3 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a><strong>左值、右值</strong></h3><p>左值是指表达式结束后依然存在的<strong>持久化对象</strong>，右值是指表达式结束时就不再存在的<strong>临时对象</strong>。所有的具名变量或者对象都是左值，而右值不具名。有一个可以区分左值和右值的便捷方法：<strong>看能不能对表达式取地址，如果能，则为左值，否则为右值</strong>。</p>
<p><strong>移动语义</strong>，简单来说解决的是各种情形下<strong>对象的资源所有权转移</strong>的问题</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">// i是左值， 0是右值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">getTemp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line">A a = getTemp();   <span class="comment">// a是左值  getTemp()的返回值是右值（临时变量）</span></span><br></pre></td></tr></table></figure>

<p>c++11中的右值引用使用的符号是&amp;&amp;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; a = <span class="number">1</span>; <span class="comment">//实质上就是将不具名(匿名)变量取了个别名</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; c = b; <span class="comment">//编译错误！ 不能将一个左值复制给一个右值引用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">getTemp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line">A&amp;&amp; a = getTemp();   <span class="comment">//getTemp()的返回值是右值（临时变量）</span></span><br></pre></td></tr></table></figure>

<p><code>getTemp()</code>返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量），而通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量<code>a</code>的生命期一样，只要<code>a</code>还活着，该右值临时变量将会一直存活下去。实际上就是给那个临时变量取了个名字</p>
<p><strong>常量左值引用</strong>却是一个“万能”的引用类型，它可以绑定<strong>非常量左值</strong>、<strong>常量左值</strong>、<strong>右值</strong>，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; a = <span class="number">1</span>; <span class="comment">//常量左值引用绑定右值， 不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">getTemp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> A &amp; a = getTemp();   <span class="comment">//不会报错 而 A&amp; a 会报错</span></span><br></pre></td></tr></table></figure>

<p>事实上，很多情况下我们用来常量左值引用的这个功能却没有意识到，如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copyable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Copyable()&#123;&#125;</span><br><span class="line">    Copyable(<span class="keyword">const</span> Copyable &amp;o) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copied"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Copyable <span class="title">ReturnRvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Copyable(); <span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcceptVal</span><span class="params">(Copyable a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcceptRef</span><span class="params">(<span class="keyword">const</span> Copyable&amp; a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pass by value: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    AcceptVal(ReturnRvalue()); <span class="comment">// 应该调用两次拷贝构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pass by reference: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    AcceptRef(ReturnRvalue()); <span class="comment">//应该只调用一次拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>期望</strong>中<code>AcceptVal(ReturnRvalue())</code>需要调用两次拷贝构造函数，一次在<code>ReturnRvalue()</code>函数中，构造好了<code>Copyable</code>对象，返回的时候会调用拷贝构造函数生成一个临时对象，在调用<code>AcceptVal()</code>时，又会将这个对象拷贝给函数的局部变量<code>a</code>，一共调用了两次拷贝构造函数。而<code>AcceptRef()</code>的不同在于形参是常量左值引用，它能够接收一个右值，而且不需要拷贝</p>
<p><strong>而实际的结果是，不管哪种方式，一次拷贝构造函数都没有调用！</strong></p>
<p>这是由于编译器默认开启了返回值优化(RVO, Return Value Optimization)。编译器很聪明，发现在<code>ReturnRvalue</code>内部生成了一个对象，返回之后还需要生成一个临时对象调用拷贝构造函数，很麻烦，所以直接优化成了1个对象对象，避免拷贝，而这个临时变量又被赋值给了函数的形参，还是没必要，所以最后这三个变量都用一个变量替代了，不需要调用拷贝构造函数。</p>
</blockquote>
<p>为了更好的观察结果，可以在编译的时候加上<code>-fno-elide-constructors</code>选项(关闭返回值优化)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g++ test.cpp -o test -fno-elide-constructors</span></span><br><span class="line">pass by value: </span><br><span class="line">Copied</span><br><span class="line">Copied <span class="comment">//可以看到确实调用了两次拷贝构造函数</span></span><br><span class="line">pass by reference: </span><br><span class="line">Copied</span><br></pre></td></tr></table></figure>

<p>上面这个例子本意是想说明常量左值引用能够绑定一个右值，可以减少一次拷贝（使用非常量的左值引用会编译失败）</p>
<p>总结一下</p>
<ol>
<li>左值引用， 使用 <code>T&amp;</code>, 只能绑定<strong>左值</strong></li>
<li>右值引用， 使用 <code>T&amp;&amp;</code>， 只能绑定<strong>右值</strong></li>
<li>常量左值， 使用 <code>const T&amp;</code>, 既可以绑定<strong>左值</strong>又可以绑定<strong>右值</strong></li>
<li>已命名的<strong>右值引用</strong>，编译器会认为是个<strong>左值</strong></li>
</ol>
<hr>
<h3 id="移动构造和移动赋值"><a href="#移动构造和移动赋值" class="headerlink" title="移动构造和移动赋值"></a><strong>移动构造和移动赋值</strong></h3><p>回顾一下如何用c++实现一个字符串类<code>MyString</code>，<code>MyString</code>内部管理一个C语言的<code>char *</code>数组，这个时候一般都需要实现拷贝构造函数和拷贝赋值函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line"><span class="comment">//    static size_t CCtor; //统计调用拷贝构造函数的次数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">   MyString(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">          <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">          *m_data = <span class="string">'\0'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">   MyString(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">       CCtor ++;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str)&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~MyString() &#123;</span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间，不这么做，调用的次数可能远大于1000</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.push_back(MyString(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看起来挺不错，却发现执行了<code>1000</code>次拷贝构造函数，如果<code>MyString(&quot;hello&quot;)</code>构造出来的字符串本来就很长，构造一遍就很耗时了，最后却还要拷贝一遍，而<code>MyString(&quot;hello&quot;)</code>只是临时对象，拷贝完就没什么用了，这就造成了没有意义的资源申请和释放操作，如果能够直接使用临时对象已经申请的资源，既能节省资源，又能节省资源申请和释放的时间。而<code>C++11</code>新增加的<strong>移动语义</strong>就能够做到这一点。</p>
<p>要实现移动语义就必须增加两个函数：<strong>移动构造函数</strong>和<strong>移动赋值构造函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MCtor; <span class="comment">//统计调用移动构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CAsgn; <span class="comment">//统计调用拷贝赋值函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MAsgn; <span class="comment">//统计调用移动赋值函数的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">   MyString(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">          <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">          *m_data = <span class="string">'\0'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">   MyString(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">       CCtor ++;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 移动构造函数</span></span><br><span class="line">   MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">       :m_data(str.m_data) &#123;</span><br><span class="line">       MCtor ++;</span><br><span class="line">       str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str)&#123;</span><br><span class="line">       CAsgn ++;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">       MAsgn ++;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = str.m_data;</span><br><span class="line">       str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~MyString() &#123;</span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.push_back(MyString(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CCtor = "</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"MCtor = "</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CAsgn = "</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"MAsgn = "</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">CCtor = 0</span></span><br><span class="line"><span class="comment">MCtor = 1000</span></span><br><span class="line"><span class="comment">CAsgn = 0</span></span><br><span class="line"><span class="comment">MAsgn = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到，移动构造函数与拷贝构造函数的区别是，拷贝构造的参数是<code>const MyString&amp; str</code>，是<em>常量左值引用</em>，而移动构造的参数是<code>MyString&amp;&amp; str</code>，是<em>右值引用</em>，而<code>MyString(&quot;hello&quot;)</code>是个临时对象，是个右值，优先进入<strong>移动构造函数</strong>而不是拷贝构造函数。而移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr。下面这张图可以解释copy和move的区别。</p>
<img src="/2020/10/06/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/4427263-81a47fdc9b8d9e98.png" alt="img" style="zoom:85%;">



<p>对于一个左值，肯定是调用拷贝构造函数了，但是有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？<code>C++11</code>为了解决这个问题，提供了<code>std::move()</code>方法来将左值转换为右值，从而方便应用移动语义。<strong>std::move()实际上是static_cast&lt;T&amp;&amp;&gt;()的简单封装。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="function">MyString <span class="title">tmp</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">        vecStr.push_back(tmp); <span class="comment">//调用的是拷贝构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CCtor = "</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"MCtor = "</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CAsgn = "</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"MAsgn = "</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    MyString::CCtor = <span class="number">0</span>;</span><br><span class="line">    MyString::MCtor = <span class="number">0</span>;</span><br><span class="line">    MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line">    MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr2;</span><br><span class="line">    vecStr2.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="function">MyString <span class="title">tmp</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">        vecStr2.push_back(<span class="built_in">std</span>::move(tmp)); <span class="comment">//调用的是移动构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CCtor = "</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"MCtor = "</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CAsgn = "</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"MAsgn = "</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">CCtor = 1000</span></span><br><span class="line"><span class="comment">MCtor = 0</span></span><br><span class="line"><span class="comment">CAsgn = 0</span></span><br><span class="line"><span class="comment">MAsgn = 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CCtor = 0</span></span><br><span class="line"><span class="comment">MCtor = 1000</span></span><br><span class="line"><span class="comment">CAsgn = 0</span></span><br><span class="line"><span class="comment">MAsgn = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>下面再举几个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"hello"</span>)</span></span>; <span class="comment">//调用构造函数</span></span><br><span class="line"><span class="function">MyString <span class="title">str2</span><span class="params">(<span class="string">"world"</span>)</span></span>; <span class="comment">//调用构造函数</span></span><br><span class="line"><span class="function">MyString <span class="title">str3</span><span class="params">(str1)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">MyString <span class="title">str4</span><span class="params">(<span class="built_in">std</span>::move(str1))</span></span>; <span class="comment">// 调用移动构造函数、</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; str1.get_c_str() &lt;&lt; endl; // 此时str1的内部指针已经失效了！不要使用</span></span><br><span class="line"><span class="comment">//注意：虽然str1中的m_dat已经称为了空，但是str1这个对象还活着，知道出了它的作用域才会析构！而不是move完了立刻析构</span></span><br><span class="line">MyString str5;</span><br><span class="line">str5 = str2; <span class="comment">//调用拷贝赋值函数</span></span><br><span class="line">MyString str6;</span><br><span class="line">str6 = <span class="built_in">std</span>::move(str2); <span class="comment">// //调用移动赋值函数，str2的内容也失效了，不要再使用</span></span><br></pre></td></tr></table></figure>

<p>需要注意一下几点：</p>
<ol>
<li><code>str6 = std::move(str2)</code>，虽然将<code>str2</code>的资源给了<code>str6</code>，但是<code>str2</code>并没有立刻析构，只有在<code>str2</code>离开了自己的作用域的时候才会析构，所以，如果继续使用<code>str2</code>的<code>m_data</code>变量，可能会发生意想不到的错误。</li>
<li>如果我们没有提供移动构造函数，只提供了拷贝构造函数，<code>std::move()</code>会失效但是不会发生错误，因为编译器找不到移动构造函数就去寻找拷贝构造函数，也这是拷贝构造函数的参数是<code>const T&amp;</code>常量左值引用的原因</li>
<li><code>c++11</code>中的所有容器都实现了<code>move</code>语义，<code>move</code>只是转移了资源的控制权，本质上是将左值强制转化为右值使用，以用于移动拷贝或赋值，避免对<strong>含有资源的对象</strong>发生无谓的拷贝。<code>move</code>对于拥有如内存、文件句柄等资源的成员的对象有效，如果是一些基本类型，如int和char[10]数组等，如果使用move，仍会发生拷贝（因为没有对应的移动构造函数），所以说<code>move</code>对含有资源的对象说更有意义</li>
</ol>
<p><strong>universal references(通用引用)</strong></p>
<p>当右值引用和模板结合的时候，就复杂了。<code>T&amp;&amp;</code>并不一定表示右值引用，它可能是个左值引用又可能是个右值引用。例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">10</span>);  <span class="comment">//10是右值</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>; <span class="comment">//</span></span><br><span class="line">f(x); <span class="comment">//x是左值</span></span><br></pre></td></tr></table></figure>

<p>如果上面的函数模板表示的是右值引用的话，肯定是不能传递左值的，但是事实却是可以。这里的<code>&amp;&amp;</code>是一个未定义的引用类型，称为<code>universal references</code>，它必须被初始化，它是左值引用还是右值引用却决于它的初始化，如果它被一个左值初始化，它就是一个左值引用；如果被一个右值初始化，它就是一个右值引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( T&amp;&amp; param)</span></span>; <span class="comment">//这里T的类型需要推导，所以&amp;&amp;是一个 universal references</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  Test(Test&amp;&amp; rhs); <span class="comment">//Test是一个特定的类型，不需要类型推导，所以&amp;&amp;表示右值引用  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Test&amp;&amp; param)</span></span>; <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复杂一点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">//在调用这个函数之前，这个vector&lt;T&gt;中的推断类型</span></span><br><span class="line"><span class="comment">//已经确定了，所以调用f函数的时候没有类型推断了，所以是 右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;&amp; param)</span></span>; <span class="comment">//右值引用</span></span><br><span class="line"><span class="comment">// universal references仅仅发生在 T&amp;&amp; 下面，任何一点附加条件都会使之失效</span></span><br></pre></td></tr></table></figure>

<p>所以最终还是要看<code>T</code>被推导成什么类型，如果<code>T</code>被推导成了<code>string</code>，那么<code>T&amp;&amp;</code>就是<code>string&amp;&amp;</code>，是个右值引用，如果<code>T</code>被推导为<code>string&amp;</code>，就会发生类似<code>string&amp; &amp;&amp;</code>的情况，对于这种情况，<code>c++11</code>增加了引用折叠的规则，总结如下：</p>
<ol>
<li>所有的右值引用叠加到右值引用上仍然使一个右值引用。</li>
<li>所有的其他引用类型之间的叠加都将变成左值引用。</li>
</ol>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="built_in">string</span>, T&gt;::value)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"string"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="built_in">string</span>&amp;, T&gt;::value)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"string&amp;"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="built_in">string</span>&amp;&amp;, T&gt;::value)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"string&amp;&amp;"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, T&gt;::value)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>&amp;, T&gt;::value)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int&amp;"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>&amp;&amp;, T&gt;::value)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int&amp;&amp;"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"unkown"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    f(<span class="number">1</span>); <span class="comment">// 参数是右值 T推导成了int, 所以是int&amp;&amp; param, 右值引用</span></span><br><span class="line">    f(x); <span class="comment">// 参数是左值 T推导成了int&amp;, 所以是int&amp;&amp;&amp; param, 折叠成 int&amp;,左值引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; a = <span class="number">2</span>;</span><br><span class="line">    f(a); <span class="comment">//虽然a是右值引用，但它还是一个左值， T推导成了int&amp;</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"hello"</span>;</span><br><span class="line">    f(str); <span class="comment">//参数是左值 T推导成了string&amp;</span></span><br><span class="line">    f(<span class="built_in">string</span>(<span class="string">"hello"</span>)); <span class="comment">//参数是右值， T推导成了string</span></span><br><span class="line">    f(<span class="built_in">std</span>::move(str));<span class="comment">//参数是右值， T推导成了string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，归纳一下， 传递左值进去，就是左值引用，传递右值进去，就是右值引用。如它的名字，这种类型确实很”通用”，下面要讲的完美转发，就利用了这个特性</p>
<hr>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a><strong>完美转发</strong></h3><p>所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"process(int&amp;):"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"process(int&amp;&amp;):"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myforward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myforward(int&amp;&amp;):"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    process(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    process(a); <span class="comment">//a被视为左值 process(int&amp;):0</span></span><br><span class="line">    process(<span class="number">1</span>); <span class="comment">//1被视为右值 process(int&amp;&amp;):1</span></span><br><span class="line">    process(move(a)); <span class="comment">//强制将a由左值改为右值 process(int&amp;&amp;):0</span></span><br><span class="line">    myforward(<span class="number">2</span>);  <span class="comment">//右值经过forward函数转交给process函数，却称为了一个左值，</span></span><br><span class="line">    <span class="comment">//原因是该右值有了名字  所以是 process(int&amp;):2</span></span><br><span class="line">    myforward(move(a));  <span class="comment">// 同上，在转发的时候右值变成了左值  process(int&amp;):0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子就是不完美转发，而c++中提供了一个<code>std::forward()</code>模板函数解决这个问题。将上面的<code>myforward()</code>函数简单改写一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myforward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myforward(int&amp;&amp;):"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    process(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myforward(<span class="number">2</span>); <span class="comment">// process(int&amp;&amp;):2</span></span><br></pre></td></tr></table></figure>

<p>上面修改过后还是不完美转发，<code>myforward()</code>函数能够将右值转发过去，但是并不能够转发左值，解决办法就是借助<code>universal references</code>通用引用类型和<code>std::forward()</code>模板函数共同实现完美转发。例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">int</span> &amp;&amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">int</span> &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"const rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"const lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里利用了universal references，如果写T&amp;,就不支持传入右值，而写T&amp;&amp;，既能支持左值，又能支持右值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perfectForward</span><span class="params">(T &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    RunCode(forward&lt;T&gt; (t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notPerfectForward</span><span class="params">(T &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    RunCode(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    notPerfectForward(a); <span class="comment">// lvalue ref</span></span><br><span class="line">    notPerfectForward(move(b)); <span class="comment">// lvalue ref</span></span><br><span class="line">    notPerfectForward(c); <span class="comment">// const lvalue ref</span></span><br><span class="line">    notPerfectForward(move(d)); <span class="comment">// const lvalue ref</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    perfectForward(a); <span class="comment">// lvalue ref</span></span><br><span class="line">    perfectForward(move(b)); <span class="comment">// rvalue ref</span></span><br><span class="line">    perfectForward(c); <span class="comment">// const lvalue ref</span></span><br><span class="line">    perfectForward(move(d)); <span class="comment">// const rvalue ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>移动语义对<code>swap()</code>函数的影响也很大，之前实现swap可能需要三次内存拷贝，而有了移动语义后，就可以实现高性能的交换函数了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(<span class="built_in">std</span>::move(a))</span></span>;</span><br><span class="line">    a = <span class="built_in">std</span>::move(b);</span><br><span class="line">    b = <span class="built_in">std</span>::move(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果T是可移动的，那么整个操作会很高效，如果不可移动，那么就和普通的交换函数是一样的，不会发生什么错误，很安全。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol>
<li>由两种值类型，左值和右值</li>
<li>有三种引用类型，左值引用、右值引用和通用引用。左值引用只能绑定左值，右值引用只能绑定右值，通用引用由初始化时绑定的值的类型确定</li>
<li>左值和右值是独立于他们的类型的，右值引用可能是左值可能是右值，如果这个右值引用已经被命名了，他就是左值</li>
<li>引用折叠规则：所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都为左值引用。当<code>T&amp;&amp;</code>为模板参数时，输入左值，它将变成左值引用，输入右值则变成具名的右值应用。</li>
<li>移动语义可以减少无谓的内存拷贝，要想实现移动语义，需要实现移动构造函数和移动赋值函数</li>
<li><code>std::move()</code>将一个左值转换成一个右值，强制使用移动拷贝和赋值函数，这个函数本身并没有对这个左值什么特殊操作</li>
<li><code>std::forward()</code>和<code>universal references</code>通用引用共同实现完美转发。</li>
<li>用<code>empalce_back()</code>替换<code>push_back()</code>增加性能</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性哈希算法原理</title>
    <url>/2020/10/06/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="一致性哈希算法的原理"><a href="#一致性哈希算法的原理" class="headerlink" title="一致性哈希算法的原理"></a>一致性哈希算法的原理</h3><p><strong>传统哈希(硬哈希)</strong></p>
<p>分布式系统中，假设有 n 个节点，传统方案使用 <code>mod(key, n)</code> 映射数据和节点</p>
<p>当扩容或缩容时(哪怕只是增减1个节点)，映射关系变为 <code>mod(key, n+1)</code> / <code>mod(key, n-1)</code>，绝大多数数据的映射关系都会失效。</p>
<p> <strong>一致性哈希(Consistent Hashing)</strong></p>
<p>一致性hash时采用如下步骤：</p>
<ol>
<li>首先求出memcached服务器（节点）的哈希值，并将其配置到0～2^32的圆（continuum）上。</li>
<li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li>
<li>然后从数据映射到的位置开始<strong>顺时针</strong>查找，将数据保存到找到的第一个服务器上。如果超过2^32仍然找不到服务器，就会保存到第一台memcached服务器上</li>
</ol>
<img src="/2020/10/06/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/498077-20160822172408386-366341651.png" alt="img" style="zoom:80%;">

<p>从上图的状态中添加一台memcached服务器。余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但Consistent Hashing中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响，如下图所示：</p>
<img src="/2020/10/06/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/498077-20160822172431933-546286787.png" alt="img" style="zoom: 80%;">

<p><strong>一致性哈希的数据倾斜问题</strong></p>
<p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题。比如只有 2 台机器，这 2 台机器离的很近，那么顺时针第一个机器节点上将存在大量的数据，第二个机器节点上数据会很少。如下图所示，D0 机器承载了绝大多数的数据</p>
<img src="/2020/10/06/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/9463862-5c4a30fc748af580.png" alt="img" style="zoom:80%;">

<p>为了避免出现数据倾斜问题，一致性 Hash 算法引入了<strong>虚拟节点的机制</strong>，也就是每个机器节点会进行多次哈希，最终每个机器节点在哈希环上会有多个虚拟节点存在，使用这种方式来大大削弱甚至避免数据倾斜问题。同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“D1#1”、“D1#2”、“D1#3”三个虚拟节点的数据均定位到 D1 上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布</p>
<img src="/2020/10/06/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/9463862-4a6ebf0a5fc331e6.png" alt="img" style="zoom:80%;">

<p><strong>良好的分布式cahce系统中的一致性hash算法应该满足以下几个方面：</strong></p>
<ul>
<li><strong>平衡性(Balance)</strong></li>
</ul>
<p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
<ul>
<li><strong>单调性(Monotonicity)</strong></li>
</ul>
<p>单调性是指当地址空间增大时，通过哈希函数所得到的关键字的哈希地址也能映射的新的地址空间，而不是仅限于原先的地址空间。或等地址空间减少时，也是只能映射到有效的地址空间中。简单的哈希函数往往不能满足此性质。而在P2P系统内，缓冲的变化等价于Peer加入或退出系统，这一情况在P2P系统中会频繁发生，因此会带来极大计算和传输负荷。单调性就是要求哈希算法能够应对这种情况。</p>
<ul>
<li><strong>分散性(Spread)</strong></li>
</ul>
<p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p>
<ul>
<li><strong>负载(Load)</strong></li>
</ul>
<p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>建立TCP连接的系统调用</title>
    <url>/2020/10/06/%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>建立TCP连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。如下图所示：</p>
<img src="/2020/10/06/%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/20180804211807158" alt="这里写图片描述" style="zoom:100%;">

<p>socket所处层次：</p>
<img src="/2020/10/06/%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/20180805091934884" alt="这里写图片描述" style="zoom:80%;">

<h3 id="socket接口"><a href="#socket接口" class="headerlink" title="socket接口"></a><strong>socket接口</strong></h3><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> protofamily, <span class="keyword">int</span> so_type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数解释：</strong></p>
<ul>
<li><p>protofamily： 指协议族，常见的值有：</p>
<p>AF_INET，指定so_pcb中的地址要采用ipv4地址类型<br>AF_INET6，指定so_pcb中的地址要采用ipv6的地址类型<br>AF_LOCAL/AF_UNIX，指定so_pcb中的地址要使用绝对路径名</p>
</li>
<li><p>so_type：指定socket的类型，比较常用的类型有：</p>
<p>SOCK_STREAM —– TCP类型，保证数据顺序及可靠性；<br>SOCK_DGRAM ——UDP类型，不保证数据接收的顺序，非可靠连接；<br>SOCK_RAW ——原始类型，允许对底层协议如IP或ICMP进行直接访问，不太常用</p>
</li>
<li><p>protocol： 指定具体的协议，也就是指定本次通信能接受的数据包的类型和发送数据包的类型，常见的值有：<br>IPPROTO_TCP，TCP协议<br>IPPROTO_UDP，UPD协议<br>如果调用者不希望特别指定使用的协议，则置为0，使用默认的连接模式。</p>
</li>
</ul>
<p><strong>函数返回值：</strong>根据这三个参数建立一个套接字，并将相应的资源分配给它，同时返回一个整型套接字号</p>
<hr>
<h3 id="bind接口"><a href="#bind接口" class="headerlink" title="bind接口"></a><strong>bind接口</strong></h3><p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数功能：</strong>将创建的socket绑定到指定的IP地址和端口上，通常是第二个调用的socket接口。当socket函数返回一个描述符时，只是存在于其协议族的空间中，并没有分配一个具体的协议地址（这里指IPv4/IPv6和端口号的组合），bind函数可以将一组固定的地址绑定到sockfd上</p>
<p><strong>参数解释：</strong></p>
<ul>
<li>sockfd ： 是调用socket()函数创建的socket描述符</li>
<li>addr ：指明要绑定的本地IP和端口号，使用网络字节序，即大端模式</li>
<li>addrlen ：表示addr的长度</li>
<li>返回值：0 – 成功，-1 – 出错。</li>
</ul>
<p><strong>需要注意的是：</strong><br>通常服务器在启动的时候都会绑定一个众所周知的协议地址，用于提供服务，客户就可以通过它来接连服务器；而客户端可以指定IP或端口也可以都不指定，未分配则系统自动分配。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个</p>
<hr>
<h3 id="listen接口"><a href="#listen接口" class="headerlink" title="listen接口"></a>listen接口</h3><p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>参数解释：</strong></p>
<ul>
<li>sockfd：是调用socket()函数创建的socket描述符（套接字号）</li>
<li>backlog：指定内核为此套接字维护的最大连接个数，该队列不能太长也不能没有，因为当队列太长时，需要耗费一定的资源进行维护和管理，没有的话也会降低操作系统的效率</li>
<li>返回值：listen()成功时返回0，错误时返回-1。</li>
</ul>
<p><strong>函数功能：</strong><br>listen()函数仅被TCP类型的服务器程序调用，实现监听服务，它实现2件事情：</p>
<ol>
<li>当socket()创建1个socket时，被假设为主动式套接字，也就是说它是一个将调用connect()发起连接请求的客户端套接字；函数listen()将套接口转换为被动式套接字，指示内核接受向此套接字的连接请求，调用此系统调用后tcp 状态机由close转换到listen</li>
<li>第2个参数指定了内核为此套接字排队的最大连接个数（半连接和全连接队列的和）</li>
</ol>
<hr>
<h3 id="connect接口"><a href="#connect接口" class="headerlink" title="connect接口"></a>connect接口</h3><p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *serv_addr, <span class="keyword">int</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>函数功能：</strong><br>connect()通常由TCP类型客户端调用，用来与服务器建立一个TCP连接，实际是发起3次握手过程，连接成功返回0，连接失败返回-1。<br><strong>参数解释：</strong></p>
<ul>
<li>sockfd – 本地客户端额socket描述符；</li>
<li>serv_addr – 服务器协议地址；</li>
<li>addrlen – 地址缓冲区的长度。</li>
</ul>
<p><strong>需要注意的是：</strong></p>
<ol>
<li>可以在UDP连接使用使用connect()，作用是在UDP套接字中记住目的地址和目的端口</li>
<li>UDP套接字使用connect后，如果数据报不是connect中指定的地址和端口，将被丢弃。没有调用connect的UDP套接字，将接收所有到达这个端口的UDP数据报，而不区分源端口和地址</li>
</ol>
<hr>
<h3 id="accept接口"><a href="#accept接口" class="headerlink" title="accept接口"></a>accept接口</h3><p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>函数功能：</strong><br>accept()函数仅被TCP类型的服务器程序调用，从已完成连接队列返回下一个建立成功的连接，如果已完成连接队列为空，线程进入阻塞态睡眠状态。成功时返回套接字描述符，错误时返回-1。<br><strong>参数解释：</strong></p>
<ul>
<li>sockfd – socket()函数返回的描述符;</li>
<li>addr – 输出的一个sockaddr_in变量地址，该变量用来存放发起连接请求的客户端的协议地址；</li>
<li>addrten – 作为输入时指明缓冲器的长度，作为输出时指明addr的实际长度。</li>
</ul>
<p><strong>需要注意的是：</strong><br>如果accpet()执行成功，返回由内核自动生成的一个全新socket描述符，用它引用与客户端的TCP连接。通常我们把accept()第一个参数称为监听套接字（listening socket），把accept()功能返回值作为已连接套接字（connected socket）。一个服务器通常只有1个监听套接字，监听客户端的连接请求；服务器内核为每一个客户端的TCP连接维护一个已连接套接字，用它实现数据双向通信</p>
<hr>
<h3 id="listen、connect、accept的执行流程"><a href="#listen、connect、accept的执行流程" class="headerlink" title="listen、connect、accept的执行流程"></a>listen、connect、accept的执行流程</h3><img src="/2020/10/06/%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2018080511361662" alt="这里写图片描述" style="zoom:90%;">

<ol>
<li>服务器端在调用listen之后，内核会建立两个队列，SYN队列和ACCEPT队列，其中ACCPET队列的长度由backlog指定</li>
<li>服务器端在调用accpet之后，将阻塞，等待ACCPT队列直到有元素</li>
<li>客户端在调用connect之后，将开始发起SYN请求，请求与服务器建立连接，此时称为第一次握手</li>
<li>服务器端在接受到SYN请求之后，把请求方放入SYN队列中，并给客户端回复一个确认帧ACK，此帧还会携带一个请求与客户端建立连接的请求标志，也就是SYN，这称为第二次握手</li>
<li>客户端收到SYN+ACK帧后，connect返回，并发送确认建立连接帧ACK给服务器端。这称为第三次握手</li>
<li>服务器端收到ACK帧后，会把请求方从SYN队列中移出，放至ACCEPT队列中，而accept函数也等到了自己的资源，从阻塞中唤醒，从ACCEPT队列中取出请求方，重新建立一个新的sockfd，并返回</li>
</ol>
<hr>
<h3 id="send接口"><a href="#send接口" class="headerlink" title="send接口"></a>send接口</h3><p>**函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>函数功能：</strong>主要是进行TCP类型的数据发送。<br><strong>参数解释：</strong></p>
<ul>
<li>sockfd – 发送端套接字描述符（非监听描述符）。</li>
<li>msg – 待发送数据的缓冲区。</li>
<li>len – 待发送数据的字节长度。</li>
<li>flags – 一般情况下置为0。</li>
</ul>
<hr>
<h3 id="recv接口"><a href="#recv接口" class="headerlink" title="recv接口"></a>recv接口</h3><p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>函数功能：</strong>主要用于TCP类型的数据接收。<br><strong>参数解释：</strong><br>- sockefd – 接收端套接字描述符（非监听描述符）；</p>
<ul>
<li>buf – 接收缓冲区的基地址；</li>
<li>len – 以字节计算的接收缓冲区长度；</li>
<li>flags – 一般情况下置为0。</li>
</ul>
<p><strong>返回值：</strong>recv()从接收缓冲区拷贝数据。成功时，返回拷贝的字节数，失败返回-1。</p>
<ul>
<li>阻塞模式下，recv/recvfrom将会阻塞到缓冲区里至少有一个字节(TCP)/至少有一个完整的UDP数据报才返回，没有数据时处于休眠状态。</li>
<li>若非阻塞，则立即返回，有数据则返回拷贝的数据大小，否则返回错误-1。</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Socket</tag>
        <tag>TCP</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>锁和CAS操作</title>
    <url>/2020/10/05/%E9%94%81%E5%92%8CCAS%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="锁的机制"><a href="#锁的机制" class="headerlink" title="锁的机制"></a>锁的机制</h3><p><strong>常用的锁机制有两种：</strong></p>
<ol>
<li><p>乐观锁：假设不会发生并发冲突，每次不加锁而去完成某项操作，只在提交操作时，检查是否违反数据完整性。如果因为冲突失败就继续重试，直到成功为止。而乐观锁用到的机制就是CAS</p>
<blockquote>
<p><strong>乐观锁大多是基于数据版本记录机制实现。</strong>为数据增加一个版本标识，比如在基于数据库表的版本解决方案中，一般是通过数据库表增加一个“version”字段来实现。读取数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，<strong>将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</strong>乐观锁的缺点是不能解决脏读的问题</p>
</blockquote>
</li>
<li><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。悲观锁的实现，往往依靠底层提供的锁机制。悲观锁会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。如果所有线程都在等待其他线程释放锁，而不能主动释放锁资源，那么也会造成死锁问题</p>
</li>
</ol>
<p><strong>锁的机制存在以下问题：</strong></p>
<ol>
<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li>
<li>一个线程持有锁会导致其他所有需要次所的线程挂起</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险</li>
</ol>
<hr>
<h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>Compare And Set（或Compare And Swap），CAS是解决多线程并行情况下使用锁造成性能损耗的一种机制，<strong>CAS操作包含三个操作数——内存位置（V）、预期原值（A）、新值（B）</strong>。如果内存位置的值与预期原值相同，那么处理器会自动将内存的值更新为新值。否则，处理器不做任何操作。无论哪种情况，处理器都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更新该位置，只告诉我这个位置现在的值即可。”</p>
<p>现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是<strong>CMPXCHG</strong>汇编指令。有了这个操作，我们就可以用其来实现各种无锁的数据结构</p>
<p>这个操作可以用以下的例子来描述，意思是，看一看内存*reg里的值是不是oldval，如果是的话，则对其赋值newval，并返回true，表示更新成功，如果返回false，则表示修改失败。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *reg,<span class="keyword">int</span> oldval,<span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg_val = *reg;</span><br><span class="line">    <span class="keyword">if</span>(reg_val == oldval)</span><br><span class="line">    &#123;</span><br><span class="line">        *reg = newval;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CAS指令有什么缺点</strong>：</p>
<ol>
<li>存在ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是<strong>如果一个值原来是A，变成了B，又变成了A</strong>，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B-3A</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销</li>
<li>只能保证一个共享变量的原子操作对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁</li>
</ol>
<p>gcc从4.1.2提供了<em>_sync</em>*系列的built-in函数，用于提供加减和逻辑运算的原子操作：</p>
<p>其声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line">type __sync_add_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_sub_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_or_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_and_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_xor_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_nand_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 这两组函数的区别在于第一组返回更新前的值，第二组返回更新后的值</span></span><br></pre></td></tr></table></figure>

<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">test_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        __sync_fetch_and_add(&amp;count,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> id[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;id[i],<span class="literal">NULL</span>,test_func,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; ++i) &#123;</span><br><span class="line">        pthread_join(id[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="处理器是如何实现原子操作"><a href="#处理器是如何实现原子操作" class="headerlink" title="处理器是如何实现原子操作"></a>处理器是如何实现原子操作</h3><p><strong>总线锁定</strong></p>
<p>如果多个处理器一起对共享变量进行读改写操作（i++就是典型的读改写操作），这个读改写操作就不是原子的。各个处理器将i的值读入自己的处理器缓存中，各自对各自的缓存里的i值进行操作，然后分别写入系统内存从而导致了问题的产生。要想对共享变量的读改写操作也是原子性的，必须保证，CPU1读改写共享变量的时候，CPU2不能操作该共享变量内存地址的缓存行。</p>
<p>处理器的总线锁就是这么来保证原子性的，所谓总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将会被阻塞住，那么该处理器可以独占共享内存</p>
<blockquote>
<p><strong>然而在同一时刻我们只需要保证对某一个内存地址的操作是原子性就可以了，但是总线锁把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大</strong></p>
</blockquote>
<p><strong>缓存一致性</strong></p>
<p>缓存一致性机制整体来说，是当某块CPU对缓存中的数据进行操作了之后，就通知其他CPU放弃储存在它们内部的缓存，或者从主内存中重新读取</p>
<p>缓存一致性是通过<strong>MESI 协议</strong>实现的。MESI 协议是以缓存行(缓存的基本数据单位)的几个状态来命名的(全名是Modified、Exclusive、 Share or Invalid)。该协议要求在每个缓存行上维护两个状态位，使得每个数据单位可能处于M、E、S和I这四种状态之一，各种状态含义如下：</p>
<ul>
<li>被修改的。处于这一状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。同时其状态相对于内存中的值来说，是已经被修改的，且没有更新到内存中</li>
<li>独占的。处于这一状态的数据，只有在本CPU中有缓存，且其数据没有修改，即与内存中一致</li>
<li>共享的。处于这一状态的数据在多个CPU中都有缓存，且与内存一致</li>
<li>无效的。本CPU中的这份缓存已经无效</li>
</ul>
<p>一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。<br>一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。<br>一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S</p>
<p>当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取</p>
<p>当CPU需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他CPU置缓存无效(I)，这种情况下会性能开销是相对较大的。在写入完成后，修改其缓存状态为M</p>
<p><strong>NOTE：并非所有情况都会使用缓存一致性的，如被操作的数据不能被缓存在CPU内部或操作数据跨越多个缓存行(状态无法标识)，则处理器会调用总线锁定;另外当CPU不支持缓存锁定时，自然也只能用总线锁定了</strong></p>
]]></content>
      <categories>
        <category>锁</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>原子操作</tag>
      </tags>
  </entry>
  <entry>
    <title>链表之快慢指针</title>
    <url>/2020/10/05/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>链表的快慢指针指声明两个指针slow和fast，slow每次走一步，fast每次走两步</p>
<p>几种应用到快慢指针的场景：</p>
<p><strong>寻找链表的中点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode *p1 = head, *p2 = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p2 &amp;&amp; p2-&gt;next) &#123;</span><br><span class="line">      p1 = p1-&gt;next;</span><br><span class="line">      p2 = p2-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p1即为链表的中点</span></span><br></pre></td></tr></table></figure>

<p><strong>检测链表中是否有环</strong></p>
<p>用两个指针slow和fast，初始化指向链表头部，slow走一步，fast走两步，如果两个指针能够相遇，说明链表中有环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="comment">//检测fast-&gt;next是否为null，是因为当fast-&gt;next为null时，fast-&gt;next-&gt;next不存在</span></span><br><span class="line">        <span class="keyword">while</span>(fast  &amp;&amp; fast -&gt; next)&#123;</span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>检测链表中是否有环并找到环开始的节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123; <span class="comment">// 此时快慢指针相遇，证明链表有环</span></span><br><span class="line">                <span class="comment">// 慢指针从链表头部开始遍历</span></span><br><span class="line">                ListNode *slow2 = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != slow2) &#123; <span class="comment">// 在环开始的点相遇</span></span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    slow2 = slow2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2020/10/05/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/微信图片_20190829113352.jpg" alt="微信图片_20190829113352" style="zoom:50%;">

<p><strong>找到两个链表的相交节点</strong></p>
<p>两种方法：</p>
<ul>
<li>A, B两个链表，假设长度A&gt;B，A，B两个头节点一步步遍历，当B到达尾节点时，将B指向A的头节点，当A到达尾节点时，将A指向B的头节点，继续遍历，当两个节点相等时，即到达相交节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *ptrA = headA, *ptrB = headB;</span><br><span class="line">    <span class="keyword">while</span> (ptrA != ptrB) &#123;</span><br><span class="line">        ptrA = ptrA ? ptrA-&gt;next : headB;</span><br><span class="line">        ptrB = ptrB ? ptrB-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptrA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>将A， B两个链表连接，即A+B， B+A， 从头开始分别遍历，当相等时，即到达相交节点</li>
</ul>
<p><strong>寻找重复数</strong></p>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<img src="/2020/10/05/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/image-20201005200439527.png" alt="image-20201005200439527" style="zoom:67%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis对象</title>
    <url>/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Redis并没有直接SDS、双端链表、字典、压缩列表、整数集合等数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们之前介绍的数据结构</p>
<p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。<strong>使用对象的另一个好处是，我们可以根据不同的使用场景，为对象设置多种不同的数据结构实现</strong>，从而优化对象在不同场景下的使用效率</p>
<p>Redis共有五种对象的类型，分别是：</p>
<table>
<thead>
<tr>
<th align="center">对象</th>
<th align="center">对象type属性的值</th>
<th align="center">TYPE命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符串对象</td>
<td align="center">REDIS_STRING</td>
<td align="center">string</td>
</tr>
<tr>
<td align="center">列表对象</td>
<td align="center">REDIS_LIST</td>
<td align="center">list</td>
</tr>
<tr>
<td align="center">哈希对象</td>
<td align="center">REDIS_HASH</td>
<td align="center">hash</td>
</tr>
<tr>
<td align="center">集合对象</td>
<td align="center">REDIS_SET</td>
<td align="center">set</td>
</tr>
<tr>
<td align="center">有序集合对象</td>
<td align="center">REDIS_ZSET</td>
<td align="center">zset</td>
</tr>
</tbody></table>
<p>Redis中的一个对象的结构体表示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;        </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 不使用(对齐位)</span></span><br><span class="line">    <span class="keyword">unsigned</span> notused:<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// LRU 时间（相对于 server.lruclock）</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向对象的值</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"> </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><strong>访问时间lru</strong></p>
<p>lru表示该对象最后一次被访问的时间，其占用22个bit位。保存该值的目的是为了计算该对象的空转时长，便于后续根据空转时长来决定是否释放该键，回收内存。</p>
<p><strong>引用计数refcount</strong></p>
<p>C语言不具备自动内存回收机制，所以Redis对每一个对象设定了引用计数refcount字段，程序通过该字段的信息，在适当的时候自动释放内存进行内存回收。此功能与C++的智能指针相似。</p>
<ul>
<li>当创建一个对象时，其引用计数初始化为1；</li>
<li>当这个对象被一个新程序使用时，其引用计数加1；</li>
<li>当这个对象不再被一个程序使用时，其引用计数减1；</li>
<li>当引用计数为0时，释放该对象，回收内存。</li>
</ul>
<p><strong>编码和底层实现</strong></p>
<p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。encoding属性记录了对象使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是下表列出的常量的其中一个</p>
<table>
<thead>
<tr>
<th align="center">编码常量</th>
<th align="center">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody><tr>
<td align="center">REDIS_ENCODING_INT</td>
<td align="center">long类型的整数</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_EMBSTR</td>
<td align="center">embstr编码的简单动态字符串</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_RAW</td>
<td align="center">简单动态字符串</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_HT</td>
<td align="center">字典</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_LINKEDLIST</td>
<td align="center">双端链表</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">压缩列表</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_INTSET</td>
<td align="center">整数集合</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_SKIPLIST</td>
<td align="center">跳跃表和字典</td>
</tr>
</tbody></table>
<p>每种类型的对象都至少使用了两种不同的编码，下表列出了每种类型的对象可以使用的编码</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">编码</th>
<th align="center">对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">REDIS_STRING</td>
<td align="center">REDIS_ENCODING_INT</td>
<td align="center">使用整数值实现的字符串对象</td>
</tr>
<tr>
<td align="center">REDIS_STRING</td>
<td align="center">REDIS_ENCODING_EMBSTR</td>
<td align="center">使用embstr编码的简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td align="center">REDIS_STRING</td>
<td align="center">REDIS_ENCODING_RAW</td>
<td align="center">使用简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td align="center">REDIS_LIST</td>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">使用压缩列表实现的列表对象</td>
</tr>
<tr>
<td align="center">REDIS_LIST</td>
<td align="center">REDIS_ENCODING_LINKEDLIST</td>
<td align="center">使用双端链表实现的列表对象</td>
</tr>
<tr>
<td align="center">REDIS_HASH</td>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">使用压缩列表实现的哈希对象</td>
</tr>
<tr>
<td align="center">REDIS_HASH</td>
<td align="center">REDIS_ENCODING_HT</td>
<td align="center">使用字典实现的哈希对象</td>
</tr>
<tr>
<td align="center">REDIS_SET</td>
<td align="center">REDIS_ENCODING_INTSET</td>
<td align="center">使用整数集合实现的集合对象</td>
</tr>
<tr>
<td align="center">REDIS_SET</td>
<td align="center">REDIS_ENCODING_HT</td>
<td align="center">使用字典实现的集合对象</td>
</tr>
<tr>
<td align="center">REDIS_ZSET</td>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">使用压缩列表实现的有序集合对象</td>
</tr>
<tr>
<td align="center">REDIS_ZSET</td>
<td align="center">REDIS_ENCODING_SKIPLIST</td>
<td align="center">使用跳跃表和字典实现的有序集合对象</td>
</tr>
</tbody></table>
<p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET msg "hello wrold"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING msg</span><br><span class="line">"embstr"</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是int、raw或者embstr。</p>
<p>如果一个字符串的内容可以转换为long，那么该字符串就会被转换成为long类型，对象的ptr就会指向该long，并且对象类型也用int类型表示</p>
<p>普通的字符串有两种，embstr和raw。embstr应该是Redis 3.0新增的数据结构,在2.8中是没有的。如果字符串对象的长度小于39字节，就用embstr对象。否则用传统的raw对象。可以从下面这段代码看出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>embstr的好处</strong>有如下几点：</p>
<ul>
<li>embstr的创建只需分配一次内存，而raw为两次（一次为sds分配对象，另一次为objet分配对象，embstr省去了第一次）</li>
<li>相对地，释放内存的次数也由两次变为一次</li>
<li>embstr的objet和sds放在一起，更好地利用缓存带来的优势</li>
</ul>
<p>raw和embstr的区别可以用下面两幅图所示：</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005184457915.png" alt="image-20201005184457915" style="zoom: 67%;">

<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005184512867.png" alt="image-20201005184512867" style="zoom:67%;">

<p>字符串对象保存各类型值的编码方式</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">编码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可以用long类型保存的整数</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">可以用long double类型保存的浮点数</td>
<td align="center">embstr或者raw</td>
</tr>
<tr>
<td align="center">字符串值，或者因为长度太大而没办法用long类型表示的整数，又或者因为长度太大而没办法用long double类型表示的浮点数</td>
<td align="center">embstr或者raw</td>
</tr>
</tbody></table>
<p><strong>编码转换</strong></p>
<ul>
<li>对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得对象保存的不再是整数值，而是一个字符串值，那么字符串对象将从int变为raw</li>
<li>redis并未提供任何修改embstr的方式，即embstr是只读的形式。对embstr的修改实际上是先转换为raw再进行修改</li>
</ul>
<hr>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以是ziplist或者linkedlist。</p>
<p><code>ziplist</code>是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用ziplist存储</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005185321906.png" alt="image-20201005185321906" style="zoom:67%;">

<p><code>linkedlist</code> 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素    </p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005185429927.png" alt="image-20201005185429927" style="zoom:67%;">

<p><strong>编码转换：</strong></p>
<p>当列表对象可以同时满足以下两个条件时， 列表对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li>
<li>列表对象保存的元素数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的列表对象需要使用 <code>linkedlist</code> 编码</p>
<hr>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。</p>
<p><code>ziplist</code> 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向</li>
</ul>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005185847324.png" alt="image-20201005185847324" style="zoom:67%;">

<p><code>hashtable</code> 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值</li>
</ul>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005185935575.png" alt="image-20201005185935575" style="zoom:67%;">

<p><strong>编码转换</strong></p>
<p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li>
<li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的哈希对象需要使用 <code>hashtable</code> 编码</p>
<hr>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是 intset 或者 hashtable 。</p>
<p>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005190917671.png" alt="image-20201005190917671" style="zoom:67%;">

<p>hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005191004670.png" alt="image-20201005191004670" style="zoom:67%;">

<p><strong>编码的转换</strong></p>
<p>当集合对象可以同时满足以下两个条件时， 对象使用 <code>intset</code> 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p>
<hr>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> 。</p>
<p><code>ziplist</code> 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005191802735.png" alt="image-20201005191802735" style="zoom:67%;">

<p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p><code>zset</code> 结构中的 <code>zsl</code> 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 <code>object</code> 属性保存了元素的成员， 而跳跃表节点的 <code>score</code> 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外， <code>zset</code> 结构中的 <code>dict</code> 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005192352716.png" alt="image-20201005192352716" style="zoom:67%;">

<p><strong>编码的转换</strong></p>
<p>当有序集合对象可以同时满足以下两个条件时， 对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ol>
<p>不能满足以上两个条件的有序集合对象将使用 <code>skiplist</code> 编码。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之压缩列表</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>压缩列表是列表键和哈希键的底层实现之一。</p>
<p>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，redis就会使用压缩列表来做列表键的底层实现</p>
<p>当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</p>
<h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>压缩列表是Redis为了节约内存而开发的是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/Redis压缩列表结构.png" alt="img" style="zoom:67%;">

<p>示例：</p>
<p><img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84-Example.png" alt="img"></p>
<p>  如上图，展示了一个总长为80字节，包含3个节点的压缩列表。如果我们有一个指向压缩列表起始地址的指针p，那么表为节点的地址就是P+60</p>
<h3 id="Redis压缩列表节点的构成"><a href="#Redis压缩列表节点的构成" class="headerlink" title="Redis压缩列表节点的构成"></a>Redis压缩列表节点的构成</h3><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。</p>
<p>其中，字节数组可以是以下三种长度中的一种</p>
<ul>
<li>长度小于等于63(2^6-1)字节的字节数组;</li>
<li>长度小于等于16383(2^14-1)字节的字节数组</li>
<li>长度小于等于4294967295(2^32-1)字节的字节数组</li>
</ul>
<p>整数值可以是以下6种长度中的一种</p>
<ul>
<li>4位长,介于0至12之间的无符号整数</li>
<li>1字节长的有符号整数</li>
<li>3字节长的有符号整数</li>
<li>int16_t类型整数</li>
<li>int32_t类型整数</li>
<li>int64_t类型整数</li>
</ul>
<p>每个压缩列表节点都由 <code>previous_entry_length</code> 、 <code>encoding</code> 、 <code>content</code> 三个部分组成</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/压缩列表节点.png" alt="img" style="zoom:67%;">

<p> <strong>previous_entry_length</strong></p>
<p>节点的 previous_entry_length属性以字节为单位,记录了压缩列表中前一个节点的长度。 previous_entry_length属性的长度可以是1字节或者5字节</p>
<ul>
<li>如果前一节点的长度小于254字节，那么 previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于254字节,那么 previous_entry_length属性的长度为5字节:其中属性的第一字节会被设置为0xFE(十进制值254),而之后的四个字节则用于保存前一节点的长度</li>
</ul>
<p>因为节点的 <code>previous_entry_length</code> 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p>
<p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 <code>previous_entry_length</code> 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点</p>
<p><strong>encoding</strong></p>
<p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度</p>
<ul>
<li>一字节、两字节或者五字节长,值的最高位为00、01或者10的是字节数组编码这种编码表示节点的 content属性保存着字节数组,数组的长度由编码除去最高两位之后的其他位记录。</li>
<li>一字节长,值的最高位以11开头的是整数编码:这种编码表示节点的content属性保存着整数值,整数值的类型和长度由编码除去最高两位之后的其他位记录。</li>
</ul>
<p><strong>content</strong></p>
<p>节点的content属性负责保存节点的值,节点值可以是一个字节数组或者整数,值的类型和长度由节点的encoding属性决定</p>
<p><img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B1.png" alt="img"></p>
<hr>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>每个节点的<code>previous_entry_length</code>都记录了前一个节点的长度,如果长度小于254那么<code>previous_entry_length</code>需要用1字节来保存这个长度值。现在假设这种情况:压缩列表有多个连续的长度介于<code>250-253</code>之间的节点e1-eN。因为每个节点的长度都小于254字节，所以这些节点的<code>previous_entry_length</code>属性都是1字节长度</p>
<p>此时如果将一个长度大于254的新节点设置为压缩列表的头节点，那么这个新节点成为头节点，也就是e1节点的前置节点。此时将e1的<code>previous_entry_length</code>扩展为5字节长度,此时e1又超过了254，于是e2的<code>previous_entry_length</code>也超过了254··· .此时这些节点就会连锁式的更新，并重新分配空间</p>
<p>作者：都是浮云啊<br>链接：<a href="https://www.jianshu.com/p/6292459aff23" target="_blank" rel="noopener">https://www.jianshu.com/p/6292459aff23</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之整数集合</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis i就会使用整数集合作为集合键的底层实现</p>
<h3 id="整数集合实现"><a href="#整数集合实现" class="headerlink" title="整数集合实现"></a>整数集合实现</h3><p>整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个intset结构表示一个整数集合</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合中包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<ul>
<li>contents数组是整数集合的底层实现，整数集合的每个元素都是contents数组的个数组项(item)，各个项在数组中按值的大小<strong>从小到大有序地排列</strong>，并且数组中<strong>不包含任何重复项</strong>。</li>
<li>length属性记录了数组的长度</li>
<li>intset结构将contents属性声明为int8_t类型的数组,但实际上 contents数组并不保存任何int8_t类型的值, contents数组的真正类型取决于encoding属性的值</li>
</ul>
<p>一个整数集合实例：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/747151-20180603165111987-424577529.png" alt="img">

<hr>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面</p>
<p><strong>升级并添加新元素过程：</strong></p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间 </li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变</li>
<li>将新元素添加到底层数组里面</li>
</ol>
<blockquote>
<p>升级后新元素的摆放位置</p>
<p>因为引发升级的新元素的长度总是比整数集合现在所有的元素长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素，即新元素的位置要么在数组最开头，要么被放在数组最末尾</p>
</blockquote>
<p><strong>升级的好处：</strong></p>
<ol>
<li>提升灵活性：可随意将整数添加到整数集合中而不必考虑其类型，不会发生类型错误</li>
<li>节约内存：总是使用能容纳集合所有元素的最小类型，只有在需要的时候才会进行升级</li>
</ol>
<p><strong>升级的局限：</strong></p>
<ul>
<li>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态</li>
</ul>
<p>因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之跳跃表</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</p>
<p>跳跃表支持平均 O(log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点</p>
<p>Redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的<strong>元素数量比较多</strong>,又或者有序集合中元素的<strong>成员是比较长的字符串</strong>时, Redis就会使用跳跃表来作为有序集合健的底层实现</p>
<p>Redis 只在两个地方用到了跳跃表， 一个是实现有序集合键， 另一个是在集群节点中用作内部数据结构</p>
<hr>
<h3 id="Redis中跳跃表的实现"><a href="#Redis中跳跃表的实现" class="headerlink" title="Redis中跳跃表的实现"></a>Redis中跳跃表的实现</h3><p>Redis的跳跃表由<strong>zskiplistNode</strong>和<strong>skiplist</strong>两个结构定义,其中 zskiplistNode结构用于表示跳跃表节点,而 zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/Redis跳跃表.png" alt="Redis跳跃表" style="zoom: 67%;">

<p>上图展示了一个跳跃表示例,其中最左边的是 skiplist结构,该结构包含以下属性：</p>
<ul>
<li>header：指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)</li>
<li>tail：指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)</li>
<li>level：记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最高的节点的层数</li>
<li>length：记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<hr>
<p>结构右方的是四个 zskiplistNode结构,该结构包含以下属性：</p>
<ul>
<li><p>层(level)：节点中用1、2、L3等字样标记节点的各个层,L1代表第一层,L代表第二层,以此类推。每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的高度。</p>
<p>每个层都带有两个属性:<strong>前进指针</strong>和<strong>跨度</strong>。</p>
<ul>
<li>前进指针用于访问位于表尾方向的其他节点</li>
<li>跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)</li>
</ul>
</li>
<li><p>后退(backward)指针：节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点</p>
</li>
<li><p>分值(score)：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列</p>
</li>
<li><p>成员对象(oj)：各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span> </span><br><span class="line">    <span class="comment">//member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">   <span class="comment">// 分值</span></span><br><span class="line">   <span class="keyword">double</span> score;</span><br><span class="line">  <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  <span class="comment">// 层 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">   <span class="comment">// 前进指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">  <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> span; </span><br><span class="line">  &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之字典</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<p>字典是一种用于保存键值对（key-value pair）的抽象数据结构，在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。</p>
<p>字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。</p>
<hr>
<h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p><strong>Redis的字典使用哈希表作为底层实现</strong>，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对</p>
<p>Redis字典所使用的哈希表结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>table属性是一个<strong>数组</strong>，数组中的每个元素都指向一个dictEntry结构的指针，每个dictEntry结构保存着一个键值对。</p>
<p>size属性记录了哈希表的大小，即table数组的大小，而used属性则记录了哈希表目前已有键值对的数量。</p>
<p>sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上</p>
<p>下图展示了一个大小为4的空哈希表：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/image-20201002173245108.png" alt="image-20201002173245108" style="zoom:80%;">

<h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存一个键值对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>key属性保持着键值对中的键，而v属性则保存着键值对中的值，其中键值对中的值可以是一个指针，或者是一个整数。</p>
<p>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，来解决<strong>键冲突问题</strong>（以链表的方式解决冲突问题）。</p>
<p>如下图表示一个完成的哈希表：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/image-20201002173545433.png" alt="image-20201002173545433" style="zoom:80%;">

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>type属性和privdata属性是针对不同类型的键值对，而创建多态字典而设置的</p>
<ul>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一组用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同类型的特定函数</li>
<li>privadata属性则保存了需要传给那些类型特定函数的可选参数</li>
</ul>
<p><strong>ht属性是一个包含了两个项的数组，数组中每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，而ht[1]哈希表只对ht[0]哈希表进行<code>rehash</code>时使用</strong></p>
<p>另一个与rehash有关的就是rehashidx属性，它积累了rehash目前的进度，如果没有进行rehash，则它的值为-1</p>
<p>下图为一个普通状态下的字典结构：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/image-20201002173956795.png" alt="image-20201002173956795" style="zoom: 75%;">

<hr>
<h3 id="哈希算法和哈希冲突"><a href="#哈希算法和哈希冲突" class="headerlink" title="哈希算法和哈希冲突"></a>哈希算法和哈希冲突</h3><p>将一个新的键值对添加到字典里面的时候，程序需要先根据键值对上面的键来计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希数组的指定索引上面。</p>
<p>Redis计算哈希值和索引值的方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment">// 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p><em>Redis使用MurmurHash2算法来计算键的哈希值</em></p>
<p>Redis哈希表使用<strong>链地址法</strong>来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next构成一个单向链表，被分配到同一个索引上的节点可以用这个单向链表连接起来，从而解决键冲突问题</p>
<p>因为dictEntry节点组成的链表没有指向链表表尾的指针，为了考虑速度，<strong>程序总是将新节点添加到链表的表头位置（这样添加节点的时间复杂度为O(1)</strong></p>
<hr>
<h3 id="rehash和渐进式rehash"><a href="#rehash和渐进式rehash" class="headerlink" title="rehash和渐进式rehash"></a>rehash和渐进式rehash</h3><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a><strong>rehash</strong></h4><p>随着操作的不断进行，哈希表保存的键值对会逐渐增多或减少，为了让哈希表<strong>负载因子</strong>维持在一个合理范围之内，当哈希表保存的键值对太多或太少时，程序要对哈希表的大小进行相应的扩展或收缩。</p>
<p>Redis对字典的哈希表执行rehash的步骤如下：</p>
<ol>
<li>为字典的ht[1]哈希表分配空间，这个空间大小取决于要执行的操作<ul>
<li>如果执行的是扩展操作，则ht[1]的大小为第一个大于等于等于ht[0].used*2的2^n</li>
<li>如果执行的收缩操作，则ht[1]的大小为第一个大于等于ht[0].used的2^n</li>
</ul>
</li>
<li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]的指定位置上</li>
<li>当ht[0]包含的所有键值对都迁移到ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备</li>
</ol>
<p><strong>哈希表的扩展与收缩</strong></p>
<p>当以下条件中任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p>
<ul>
<li>服务器目前没有执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子大于等于1</li>
<li>服务器正在执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子大于等于5</li>
</ul>
<p>另一方面，当哈希表负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>Redis中的rehash动作并不是一次性、集中式完成的，而是<strong>分多次、渐进式的完成的。</strong></p>
<p>这样做的目的是，如果服务器中包含很多键值对，要一次性的将这些键值对全部rehash到ht[1]的话，庞大的计算量可能导致服务器在一段时间内停止服务于。</p>
<p>为了避免这种影响，Redis采用了<strong>渐进式Redis</strong>：</p>
<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它置为0，表示rehash工作开始</li>
<li>在rehash进行期间，<strong>每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]中</strong>，当rehash工作完成之后，程序将rehashidx属性的值+1</li>
<li>随着字典操作的不断进行，最终在某个时间点上，ht[0]的所有键值对都被rehash到ht[1]上，这时将rehashidx属性设为-1，表示rehash完成</li>
</ol>
<p><strong>渐进式rehash</strong>的好处在于其采取<strong>分而治之</strong>的方式，将rehash键值对所需要的计算工作均摊到字典的<strong>每个</strong>添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量</p>
<p><strong>渐进式rehash执行期间的哈希表操作</strong></p>
<p>因为在渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找、更新等操作都是在两个表上进行的。</p>
<p>例如，<strong>查找</strong>操作会先在ht[0]上进行，如果没找到再在ht[1]上进行。<strong>添加</strong>操作的键值对会一律保存到ht[1]中，这一措施保证ht[0]包含的键值对只会减少不会增加。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之链表</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表在 Redis 中的应用非常广泛， 比如列表键的底层实现之一就是链表： 当一个列表键包含了数量比较多的元素， 又或者列表中包含的元素都是比较长的字符串时， Redis 就会使用链表作为列表键的底层实现。</p>
<p>除了链表键之外， 发布与订阅、慢查询、监视器等功能也用到了链表， Redis 服务器本身还使用链表来保存多个客户端的状态信息， 以及使用链表来构建客户端输出缓冲区（output buffer）</p>
<p>Redis链表为双向无环链表</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/image-20201002171439480.png" alt="image-20201002171439480" style="zoom: 80%;">

<p>如图所示，Redis使用一个listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="comment">// 前置节点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span> </span><br><span class="line">	<span class="comment">// 后置节点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> </span><br><span class="line">	<span class="comment">// 节点的值 </span></span><br><span class="line">	<span class="keyword">void</span> *value; </span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>同时Redis为了方便的操作链表，提供了一个<strong>list结构</strong>来持有链表。如下图所示</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/image-20201002171607721.png" alt="image-20201002171607721" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Redis链表结构其主要特性如下:</strong></p>
<ul>
<li>双向：链表节点带有prev和next指针，获取某个节点的前驱、后继节点的时间复杂度为0(1)</li>
<li>无环: 链表为非循环链表，表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</li>
<li>带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1)</li>
<li>带链表长度计数器：通过list结构的len属性获取节点数量的时间复杂度为O(1)</li>
<li>多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之SDS</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</url>
    <content><![CDATA[<p> 字符串在Redis中使用非常广泛，在Redis中，所有的数据都保存在字典（Map）中，而字典的键就是字符串类型，并且对于很大一部分字典值数据也是又字符串组成的。以下是SDS的具体存储结构：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/202205_cXnQ_2831721.png" alt="img" style="zoom:80%;">

<p>从图中可以看出，SDS的属性有三个：len、free和buf数组：</p>
<ul>
<li>len字段是用来保存SDS字符串中所包含字符数目的</li>
<li>free字段则是用来保存buf数组中空余的部分的长度的</li>
<li>buf数组则是实际用来保存字符串的</li>
</ul>
<p>比如如下结构保存了“Hello World！”这个字符串：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/204859_FBGP_2831721.png" alt="img" style="zoom:80%;">

<p>这里需要注意的是，SDS和C字符串一样，需要在字符串结尾加上一个’\0’表示该字符串的结束（可以直接使用C字符串库里面的函数）</p>
<p><strong>Redis使用SDS结构而不用c字符串保存字符串的原因有如下几点</strong>：</p>
<ol>
<li><strong>常数复杂度获取字符串长度</strong><ul>
<li>通过读取SDS对象的len属性的值我们可以使用O(1)获取SDS对象保存的字符串长度</li>
<li>在c字符串中，我们必须对整个数组进行遍历从而获取字符串的长度，其时间复杂度为O(N)</li>
</ul>
</li>
<li><strong>杜绝缓冲区溢出</strong><ul>
<li>在C字符串中，比如char *strcat(char *dest, const char *src)函数将src连接到dest的末尾，但是c字符串假定dest数组中有足够的空余空间来保存src数组，如果dest数组长度不够就会造成缓冲区溢出</li>
<li>在SDS对象中也提供了类似的函数SDS SDScat(SDS s, const char *t)和SDS SDScatSDS(SDS s, const SDS t)，这两个函数在调用之前会检查目标SDS对象s中free属性是否能够保存要连接的字符串的长度，如果不够，就会对目标SDS对象扩容，这就保证了SDS对象不会造成缓冲区溢出</li>
</ul>
</li>
<li><strong>减少修改字符串时内存重分配的次数</strong><ul>
<li>对于c字符串，每次对其进行修改都需要进行一次空间分配和复制操作，否则会造成缓冲区溢出和内存泄漏</li>
<li>在对SDS进行修改的时候，Redis可以通过<strong>空间预分配</strong>和<strong>惰性空间释放</strong>来保证后续对SDS对象的频繁修改而不会造成SDS对象的buf数组经常分配空间<ol>
<li>空间预分配：对于追加操作来说，Redis不仅会开辟空间至够用而且还会预分配未使用的空间(free)来用于下一次操作。至于未使用的空间(free)的大小则由修改后的字符串长度决定<ul>
<li>当修改后的字符串长度len &lt; 1M,则会分配与len相同长度的未使用的空间</li>
<li>当修改后的字符串长度len &gt;= 1M,则会分配1M长度的未使用的空间</li>
</ul>
</li>
<li>惰性空间回收：在对SDS的字符串进行缩短操作的时候，程序并不会立刻使用内存重分配来回收缩短之后多出来的字节，而是使用free属性将这些字节的数量记录下来等待将来使用</li>
</ol>
</li>
</ul>
</li>
<li><strong>二进制安全</strong><ul>
<li>对于c字符串，由于其判断是否结束的标志是从字符串开始到结尾碰到的第一个“\0”字符，这就限制了c字符串不能保存像图片、音频、视频、压缩文件等二进制保存的内容</li>
<li>对于SDS对象，由于判断其是否结束的标志是其len属性，也就是说无论在len长度内，buf数组中是否包含“\0”都不影响Redis判断其是否结束</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th align="center">C字符串</th>
<th align="center">SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">获取字符串长度的复杂度为O(N)</td>
<td align="center">获取字符串长度的复杂度为O(1)</td>
</tr>
<tr>
<td align="center">API是不安全的，可能会造成缓冲区溢出</td>
<td align="center">API是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td align="center">修改字符串长度N次必然需要执行N次内存分配操作</td>
<td align="center">修改字符串长度N次最多需要执行N次内存分配操作</td>
</tr>
<tr>
<td align="center">只能保存文本数据</td>
<td align="center">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td align="center">可以使用所有&lt;string.h&gt;库中的函数</td>
<td align="center">可以使用一部分&lt;string.h&gt;库中的函数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库缓冲池</title>
    <url>/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/</url>
    <content><![CDATA[<p>应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在<strong>缓存</strong>(cache)里，避免每次都去访问数据库。操作系统会有<strong>缓冲池</strong>(buffer pool)机制，避免每次都访问磁盘，以加速数据的访问。MySQL作为一个存储系统，同样具有<strong>缓冲池</strong>(buffer pool)机制，以避免每次查询数据都进行磁盘IO</p>
<p><strong>InnoDB的缓冲池缓存什么？有什么用？</strong></p>
<p>缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用。</p>
<p><strong>如何管理与淘汰缓冲池，使得性能最大化呢？</strong></p>
<p>在介绍具体细节之前，先介绍下“预读”的概念。</p>
<p><strong>什么是预读？</strong>磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。 </p>
<p><strong>预读为什么有效？</strong>数据访问，通常都遵循“集中读写”的原则，使用一些数据，大概率会使用附近的数据，这就是所谓的“局部性原理”，它表明提前加载是有效的，确实能够减少磁盘IO。 </p>
<p><strong>按页(4K)读取，和InnoDB的缓冲池设计有啥关系？</strong>（1）磁盘访问按页读取能够提高性能，所以缓冲池一般也是按页缓存数据；（2）预读机制启示了我们，能把一些“可能要访问”的页提前加入缓冲池，避免未来的磁盘IO操作；</p>
<p><strong>InnoDB是以什么算法，来管理这些缓冲页呢？</strong>最容易想到的，就是LRU(Least recently used)。</p>
<p><strong>传统的LRU是如何进行缓冲页管理？</strong>最常见的玩法是，把入缓冲池的页放到LRU的头部，作为最近访问的元素，从而最晚被淘汰。这里又分两种情况：（1）<strong>页已经在缓冲池里</strong>，那就只做“移至”LRU头部的动作，而没有页被淘汰；（2）<strong>页不在缓冲池里</strong>，除了做“放入”LRU头部的动作，还要做“淘汰”LRU尾部页的动作；</p>
<p>虽然传统的LRU缓冲池算法十分直观，但这里有两个问题：（1）<strong>预读失效</strong>；（2）<strong>缓冲池污染</strong></p>
<p><strong>什么是预读失效？</strong>由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效。</p>
<p><strong>如何对预读失效进行优化？</strong>要优化预读失效，思路是：（1）让预读失败的页，停留在缓冲池LRU里的时间尽可能短；（2）让真正被读取的页，才挪到缓冲池LRU的头部；以保证，真正被读取的热数据留在缓冲池里的时间尽可能长。</p>
<p><strong>具体方法是</strong>：</p>
<ol>
<li>将LRU分为两个部分：新生代(new sublist)老生代(old sublist)</li>
<li>新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)</li>
<li>新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：如果数据真正被读取（预读成功），才会加入到新生代的头部如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池</li>
</ol>
<p><strong>举个例子，整个缓冲池LRU如图：</strong></p>
<p>（1）整个LRU长度是10（2）前70%是新生代（3）后30%是老生代（4）新老生代首尾相连</p>
<img src="/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/Image.png" alt="Image" style="zoom: 95%;">

<p>假如有一个页号为50的新页被预读加入缓冲池：</p>
<ol>
<li>50只会从老生代头部插入，老生代尾部（也是整体尾部）的页会被淘汰掉；</li>
<li>假设50这一页不会被真正读取，即预读失败，它将比新生代的数据更早淘汰出缓冲池；</li>
</ol>
<img src="/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/Image-1594741614324.png" alt="Image" style="zoom:95%;">

<p>假如50这一页立刻被读取到，例如SQL访问了页内的行row数据：</p>
<ol>
<li>它会被立刻加入到新生代的头部；</li>
<li>新生代的页会被挤到老生代，此时并不会有页面被真正淘汰；</li>
</ol>
<img src="/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/Image-1594747637932.png" alt="Image" style="zoom:95%;">

<p><strong>老生代改进版LRU仍然解决不了缓冲池污染的问题。</strong></p>
<p><strong>什么是MySQL缓冲池污染？</strong></p>
<p>当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。 </p>
<p>例如，有一个数据量较大的用户表，当执行：select * from user where name like “%foo%”，虽然结果集可能只有少量数据，但这类like不能命中索引，必须全表扫描，就需要访问大量的页：</p>
<ol>
<li>把页加到缓冲池（插入老生代头部）；</li>
<li>从页里读出相关的row（插入新生代头部）；</li>
<li>row里的name字段和字符串foo进行比较，如果符合条件，加入到结果集中；</li>
<li>直到扫描完所有页中的所有row</li>
</ol>
<p>如此一来，所有的数据页都会被加载到新生代的头部，但只会访问一次，真正的热数据被大量换出。</p>
<p><strong>怎么处理这类扫码大量数据导致的缓冲池污染问题呢？</strong></p>
<p>MySQL缓冲池加入了一个“<strong>老生代停留时间窗口</strong>”的机制：</p>
<ol>
<li>假设T=老生代停留时间窗口；</li>
<li>插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部</li>
<li>只有满足“<strong>被访问”</strong>并且“<strong>在老生代停留时间”大于T</strong>，才会被放入新生代头部；</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li>缓冲池(buffer pool)是一种<strong>常见的降低磁盘访问的机制；</strong></li>
<li>缓冲池通常<strong>以页(page)为单位缓存数据</strong>；</li>
<li>缓冲池的<strong>常见管理算法是LRU</strong>，memcache，OS，InnoDB都使用了这种算法；</li>
<li>InnoDB对普通LRU进行了优化：<ul>
<li>将缓冲池分为<strong>老生代和新生代</strong>，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，<strong>以解决预读失效的问题</strong></li>
<li><strong>页被访问</strong>，且在老生代<strong>停留时间超过配置阈值</strong>的，才进入新生代，<strong>以解决批量数据访问，大量热数据淘汰的问题</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>前置++和后置++</title>
    <url>/2020/03/07/%E5%89%8D%E7%BD%AE++%E5%92%8C%E5%90%8E%E7%BD%AE++/</url>
    <content><![CDATA[<p>++a表示取a的地址，增加它的内容，然后把值放在寄存器中；</p>
<p>a++表示取a的地址，把它的值装入寄存器，然后增加内存中的a的值；</p>
<p><strong>前置++和后置++的重载</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Age &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Age <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        Age tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Age a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码，我们可以看出前置++和后置++，有4点不同：</p>
<ol>
<li>返回类型不同</li>
<li>形参不同</li>
<li>代码不同</li>
<li>效率不同</li>
</ol>
<p><strong>1. 返回值类型的区别</strong></p>
<p>前置++的返回类型是Age&amp;，后置++的返回类型const Age。这意味着，前置++返回的是左值，后置++返回的是右值</p>
<p>左值和右值，决定了前置++和后置++的用法</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">int</span> <span class="comment">main()</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">Age</span> <span class="comment">a;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span>    <span class="comment">(a</span>++<span class="comment">)</span>++<span class="comment">;</span>  <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment"></span>    ++<span class="comment">(a</span>++<span class="comment">);</span>  <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">a</span>++ <span class="comment">=</span> <span class="comment">1;</span>   <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">(</span>++<span class="comment">a)</span>++<span class="comment">;</span>  <span class="comment">//OK</span></span><br><span class="line"><span class="comment"></span>    ++<span class="comment">(</span>++<span class="comment">a);</span>  <span class="comment">//OK</span></span><br><span class="line"><span class="comment"></span>    ++<span class="comment">a</span> <span class="comment">=</span> <span class="comment">1;</span>   <span class="comment">//OK</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<p>++的类型是const Age，自然不能对它进行前置++、后置++、赋值等操作。</p>
<p>++a的类型是Age&amp;，当然可以对它进行前置++、后置++、赋值等操作</p>
<p><strong>a++的返回类型为什么要是const对象呢？</strong></p>
<p>对于内置类型，(i++)++这样的表达式是不能通过编译的。自定义类型的操作符重载，应该与内置类型保持行为一致</p>
<p><strong>2. 形参不同</strong></p>
<p>前置++没有形参，而后置++有一个int形参</p>
<p><strong>3.代码实现的区别</strong></p>
<p>前置++的实现比较简单，自增之后，将<em>this返回即可。需要注意的是，一定要返回</em>this。</p>
<p>后置++的实现稍微麻烦一些。因为要返回自增之前的对象，所以先将对象拷贝一份，再进行自增，最后返回那个拷贝</p>
<p><strong>4.效率的区别</strong></p>
<p>前置++的效率更高，理由是：后置++会生成临时对象</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>指针、数组和函数</title>
    <url>/2020/02/11/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>数组指针和指针数组</strong></p>
<p><strong>数组指针</strong></p>
<p>定义 int (*p)[n];</p>
<p>()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度</p>
<p>如要将二维数组赋给一指针，应这样赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>]; <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组。</span></span><br><span class="line">p=a;        <span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span></span><br><span class="line">p++;       <span class="comment">//该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span></span><br></pre></td></tr></table></figure>

<p><strong>指针数组</strong></p>
<p>定义 int *p[n];</p>
<p>[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值</p>
<p>如要将二维数组赋给一指针数组:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	p[i]=a[i];</span><br></pre></td></tr></table></figure>

<p>这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]，所以要分别赋值</p>
<p><strong>指针数组和数组指针的内存布局</strong></p>
<img src="/2020/02/11/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/22201218-19ddd896ae6a45e1b61c7e3ee59b4662.jpg" alt="img" style="zoom: 80%;">

<hr>
<p><strong>函数指针和指针函数</strong></p>
<p><strong>指针函数</strong></p>
<p>指针函数，简单的来说，就是一个<strong>返回指针</strong>的函数，其本质是一个函数，而该函数的返回值是一个指针。<br>声明格式为：<strong>类型标识符 *函数名(参数表)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        sum = a + b;</span><br><span class="line">        <span class="keyword">return</span> &amp;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">        p=add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add result is %d\n"</span>, *p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数指针</strong></p>
<p>函数指针，其本质是一个<strong>指针变量</strong>，该<strong>指针指向这个函数</strong>。总结来说，函数指针就是指向函数的指针。<br>声明格式：类型说明符  (*函数名)  (参数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br></pre></td></tr></table></figure>

<p>函数指针是需要把一个函数的地址赋值给它，有两种写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure>

<p>调用函数指针的方式也有两种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        p=add;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add result is %d\n"</span>, p(<span class="number">200</span>,<span class="number">300</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>一种string类的简单实现</title>
    <url>/2020/01/20/%E4%B8%80%E7%A7%8Dstring%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>C++中String类的简单实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    myString(<span class="keyword">const</span> <span class="keyword">char</span> *str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *data = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    myString(<span class="keyword">const</span> myString &amp;str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    myString(myString&amp;&amp; str):data(str.data)&#123;</span><br><span class="line">        str.data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">    myString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> myString &amp;str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">    myString&amp; <span class="keyword">operator</span>=(myString&amp;&amp; str)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = str.data;</span><br><span class="line">        str.data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~myString()&#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">String</span> s0; <span class="comment">//构造</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>; <span class="comment">//构造</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">s2</span><span class="params">(s0)</span></span>;</span><br><span class="line">    <span class="keyword">String</span> s3 = s1;</span><br><span class="line">    s2 = s1;</span><br><span class="line"></span><br><span class="line">    foo(s1);</span><br><span class="line">    bar(s1);</span><br><span class="line">    foo(<span class="string">"temporary"</span>);</span><br><span class="line">    bar(<span class="string">"temporary"</span>);</span><br><span class="line">    <span class="keyword">String</span> s4 = baz();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">String</span>&gt; svec;</span><br><span class="line">    svec.push_back(s0);</span><br><span class="line">    svec.push_back(s1);</span><br><span class="line">    svec.push_back(baz());</span><br><span class="line">    svec.push_back(<span class="string">"good job"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝赋值</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">移动构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">移动构造</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确地删除vector中符合条件的某元素</title>
    <url>/2019/11/20/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%88%A0%E9%99%A4vector%E4%B8%AD%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9F%90%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>比如，有一个vector&lt; int &gt; nums = {1, 2, 2, 2, 2, 3, 5}，要求删除nums中所有值为2的元素 </p>
<h3 id="一个符合直觉的错误实现"><a href="#一个符合直觉的错误实现" class="headerlink" title="一个符合直觉的错误实现"></a>一个符合直觉的错误实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123; </span><br><span class="line">        nums.erase(it); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码循环遍历nums中的每个元素，判断是否为2，是的话则erase掉。看起来好像没什么问题，但是实际上已经造成了bug。这段代码的执行完成后，<strong>nums存储的元素是{1, 2, 2, 3, 5}</strong>，值为2的元素并没有被全部清除掉。</p>
<p>为什么会出现这个结果呢？原因就是<strong>迭代器失效</strong> ：在第一个2被erase掉的时候，it迭代器已经失效了，它指向了被删除元素的下一个元素，用它来继续遍历vector就会漏掉被删除元素后面的第一个元素，导致2没有被完全清除。</p>
<h3 id="第一种正确实现：让it指向下一个元素"><a href="#第一种正确实现：让it指向下一个元素" class="headerlink" title="第一种正确实现：让it指向下一个元素"></a>第一种正确实现：让it指向下一个元素</h3><p><strong>erase函数的返回值是指向当前被删除元素的下一个元素的迭代器</strong>。那么我们把这个返回值赋值给it继续遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">        it = nums.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种正确实现：erase-remove"><a href="#第二种正确实现：erase-remove" class="headerlink" title="第二种正确实现：erase-remove"></a>第二种正确实现：erase-remove</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    nums.erase(<span class="built_in">remove</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(), <span class="number">2</span>), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>erase</strong>用来删除一段区间的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>remove</strong>  <strong>移除但不删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它<strong>并不真正从容器中删除那些元素</strong>（换句话说容器的大小不变），<strong>而是将每一个不与value相等（也就是我们不打算移除）的元素轮番赋值给first之后的空间</strong>。</p>
<p>例如：{0，1，0，2，0，3，0，4}，用remove移除值为0的元素，执行结果为{1，2，3，4，0，3，0，4}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>) &#123;</span></span><br><span class="line">    first = <span class="built_in">find</span>(first, last, value);</span><br><span class="line">    ForwardIterator next = first;</span><br><span class="line">    <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> remove_copy(++next, last, first, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove_copy</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">IntputIt</span> <span class="title">first</span>,<span class="title">IntputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它并不真正从容器中删除那些元素（换句话说容器的大小不变）,而是<strong>将结果复制到一个以result标示起始位置的容器上，新容器可以和原容器重叠。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">OutputIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIt</span> <span class="title">remove_copy</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first!=last;++first)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*first!=value)&#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









































]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C库函数memcpy()和memmove()的区别</title>
    <url>/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>memcpy( )和memmove( )都是C语言中的库函数，在头文件string.h中。</p>
<p>其作用是从src内存中拷贝n个字节到dest内存区域中，原型分别如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="memcpy-和memmove-的区别"><a href="#memcpy-和memmove-的区别" class="headerlink" title="memcpy()和memmove()的区别"></a>memcpy()和memmove()的区别</h3><p>他们的作用是一样的，<strong>唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。</strong></p>
<p><img src="/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/memory.png" alt="memory"></p>
<h3 id="memcpy-函数的实现"><a href="#memcpy-函数的实现" class="headerlink" title="memcpy()函数的实现"></a>memcpy()函数的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    <span class="keyword">char</span> *s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        *tmp++ = *s_src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="memmove-实现函数"><a href="#memmove-实现函数" class="headerlink" title="memmove()实现函数"></a>memmove()实现函数</h3><p>memmove就是针对第二种内存覆盖情形，对memcpy进行了改进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memmove</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s_dst;</span><br><span class="line">    <span class="keyword">char</span>* s_src;</span><br><span class="line">    s_dst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">if</span>(s_dst&gt;s_src &amp;&amp; (s_src+n&gt;s_dst)) &#123;      <span class="comment">//第二种内存覆盖的情形。</span></span><br><span class="line">        <span class="comment">// 从后往前复制，防止出现内存覆盖的情形</span></span><br><span class="line">        s_dst = s_dst+n<span class="number">-1</span>;</span><br><span class="line">        s_src = s_src+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst-- = *s_src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst++ = *s_src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title> 进程间通信有哪些方式</title>
    <url>/2019/10/11/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h3><ul>
<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li>
<li>一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；</li>
<li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)</li>
</ul>
<p><strong>管道的实质：</strong></p>
<ul>
<li>管道的实质是一个内核缓冲区，管道一端的进程顺序的将数据写入缓冲区，另一端的进程以先进先出的方式读出数据。</li>
<li>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</li>
<li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</li>
<li>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</li>
</ul>
<p><strong>管道的局限：</strong><br>管道的主要局限性正体现在它的特点上：</p>
<ul>
<li>只支持单向数据流；</li>
<li>只能用于具有亲缘关系的进程之间；</li>
<li>没有名字；</li>
<li>管道的缓冲区是有限的（管道存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li>
<li>对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。<strong>它们不支持诸如lseek()等文件定位操作</strong>。</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>
</ul>
<p>两个分别用于读写的描述符必须同时打开才行，否则会出问题。、</p>
<ol>
<li>如果关闭读 (close(pipefd[0])) 端保留写端，继续向写端 (pipefd[1]) 端写数据(write 函数)的进程会收到 SIGPIPE 信号。</li>
<li>如果关闭写 (close(pipefd[1])) 端保留读端，继续向读端 (pipefd[0]) 端读数据(read 函数)，read 函数会返回 0.</li>
</ol>
<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a><strong>命名管道</strong></h3><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。有名管道严格遵循<strong>先进先出(first in first out)</strong>，对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。<strong>它们不支持诸如lseek()等文件定位操作</strong>。<strong>有名管道的名字存在于文件系统中，内容存放在内存中</strong></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h3><ul>
<li><p>消息队列是存放在<strong>内核中的消息链表</strong>，每个消息队列由消息队列标识符表示。</p>
</li>
<li><p>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p>
</li>
<li><p>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</p>
<blockquote>
<p><strong>消息队列特点总结：</strong><br>（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br>（2）消息队列允许一个或多个进程向它写入与读取消息.<br>（3）管道和消息队列的通信数据都是先进先出的原则。<br>（4）<strong>消息队列可以实现消息的随机查询</strong>,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br>（5）消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br>（6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。System V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p>
<p>（7）<strong>消息队列不适合比较大数据的传输，消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong></p>
</blockquote>
</li>
</ul>
<h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a><strong>信号(Signal)</strong></h3><ul>
<li>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</li>
</ul>
<blockquote>
<p><strong>Linux系统中常用信号：</strong><br>（1）<strong>SIGHUP：</strong>用户从终端注销，所有已启动进程都将收到该信号。系统缺省状态下对该信号的处理是终止进程。<br>（2）<strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。<br>（3）<strong>SIGQUIT：</strong>程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。<br>（4）<strong>SIGBUS和SIGSEGV：</strong>进程访问非法地址。<br>（5）<strong>SIGFPE：</strong>运算中出现致命错误，如除零操作、数据溢出等。<br>（6）<strong>SIGKILL：</strong>用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。<br>（7）<strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。<br>（8）<strong>SIGALRM：</strong>定时器信号。<br>（9）<strong>SIGCLD：</strong>子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p>
</blockquote>
<p><strong>信号生命周期和处理流程</strong><br> （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br> （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br> （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a><strong>共享内存</strong></h3><p><strong>共享内存的机制，就是多两个进程都拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<img src="/2019/10/11/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F/Users/hqnddw/Desktop/md文件/操作系统.assets/image-20200805144151828.png" alt="image-20200805144151828" style="zoom:55%;">

<ul>
<li>使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li>
</ul>
<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量(Semaphore)"></a><strong>信号量(Semaphore)</strong></h3><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p>
<p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。为了获得共享资源，进程需要执行下列操作：</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<blockquote>
<p><strong>信号量与普通整型变量的区别：</strong></p>
<p>（1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br>（2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p>
</blockquote>
<blockquote>
<p><strong>信号量与互斥量之间的区别：</strong><br>（1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br><strong>互斥：</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br><strong>同步：</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br>（2）互斥量值只能为0/1，信号量值可以为非负整数。<br>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br>（3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p>
</blockquote>
<h3 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字(Socket)"></a><strong>套接字(Socket)</strong></h3><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了</strong></p>
<p>创建 socket 的系统调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocal)</span></span></span><br></pre></td></tr></table></figure>

<p>三个参数分别代表：</p>
<ul>
<li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；</li>
<li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM  表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li>
<li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可;</li>
</ul>
<img src="/2019/10/11/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F/Users/hqnddw/Desktop/md文件/操作系统.assets/image-20200805145828593.png" alt="image-20200805145828593" style="zoom:50%;">

<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>
<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>
<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MFCC特征提取</title>
    <url>/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h3 id="MFCC特征提取流程"><a href="#MFCC特征提取流程" class="headerlink" title="MFCC特征提取流程"></a>MFCC特征提取流程</h3><img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image.png" alt="Image" style="zoom:80%;">

<h3 id="预加重（Pre-emphasis）"><a href="#预加重（Pre-emphasis）" class="headerlink" title="预加重（Pre-emphasis）"></a>预加重（Pre-emphasis）</h3><p>语音中有频谱倾斜（Spectral Tilt）现象，即低频具有较高能量， 因此，需要加重高频语音的能量，使得高频信息凸显出来（与低频相比，预加重增加了语音信号中高频的幅度）其计算方法 ：      <img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900551638.png" alt="img"></p>
<p>x(t) 表示音频数据（可以看成一个向量）的第 t 个数，α 通常取值范围是 (0.95,0.99)</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900551638.png" alt="img" style="zoom:80%;">

<p>python代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_emphasis</span><span class="params">(signal, coeff=<span class="number">0.95</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> numpy.append(signal[<span class="number">0</span>], signal[<span class="number">1</span>:] - coeff * signal[:<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="分帧加窗（Framing-Windowing）"><a href="#分帧加窗（Framing-Windowing）" class="headerlink" title="分帧加窗（Framing-Windowing）"></a>分帧加窗（Framing-Windowing）</h3><p>特征提取时，如果每次取出 25 ms（跨度） 的语音，进行离散傅里叶变换计算出一帧，接着步移 10 ms 继续计算下一帧，这种基本做法就是矩形（Rectangular Window），棱角分明的窗容易造成<strong>频谱泄露</strong>（Spectral Leakage）， 可以选择使用钟形窗，如海明窗（Hamming Window）、 汉宁窗（Hanning Window）等。加窗的计算方法：</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900607629.png" alt="Image" style="zoom:80%;">

<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900785096.png" alt="Image" style="zoom: 67%;">

<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900800816.png" alt="Image" style="zoom:67%;">

<p><strong>python代码实现：</strong></p>
<p>实现分帧加窗</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">framesig</span><span class="params">(sig, frame_len, frame_step, winfunc=lambda x: numpy.ones<span class="params">(<span class="params">(x,)</span>)</span>, stride_trick=True)</span>:</span></span><br><span class="line"><span class="string">"""Frame a signal into overlapping frames.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:param sig: the audio signal to frame.</span></span><br><span class="line"><span class="string">:param frame_len: length of each frame measured in samples.</span></span><br><span class="line"><span class="string">:param frame_step: number of samples after the start of the previous frame that the next frame should begin.</span></span><br><span class="line"><span class="string">:param winfunc: the analysis window to apply to each frame. By default no window is applied.</span></span><br><span class="line"><span class="string">:param stride_trick: use stride trick to compute the rolling window and window multiplication faster</span></span><br><span class="line"><span class="string">:returns: an array of frames. Size is NUMFRAMES by frame_len.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    slen = len(sig)</span><br><span class="line">    <span class="comment"># 对帧长和步长取整</span></span><br><span class="line">    frame_len = int(round_half_up(frame_len))</span><br><span class="line">    frame_step = int(round_half_up(frame_step))</span><br><span class="line">    <span class="comment"># 计算帧数</span></span><br><span class="line">    <span class="keyword">if</span> slen &lt;= frame_len:</span><br><span class="line">        numframes = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        numframes = <span class="number">1</span> + int(math.ceil((<span class="number">1.0</span> * slen - frame_len) /frame_step))</span><br><span class="line">    <span class="comment"># 分帧后如果最后剩余的长度不够一帧，将所需的长度填充为零，连接到原始信号的后 面，算作一帧</span></span><br><span class="line">    padlen = int((numframes - <span class="number">1</span>) * frame_step + frame_len)</span><br><span class="line">    zeros = numpy.zeros((padlen - slen,))</span><br><span class="line">    padsignal = numpy.concatenate((sig, zeros))</span><br><span class="line">    <span class="comment"># 使用技巧加窗</span></span><br><span class="line">    <span class="keyword">if</span> stride_trick:</span><br><span class="line">    win = winfunc(frame_len)</span><br><span class="line">    frames = rolling_window(padsignal, window=frame_len, step=frame_step)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 不使用技巧</span></span><br><span class="line">    indices = numpy.tile(numpy.arange(<span class="number">0</span>, frame_len), (numframes, <span class="number">1</span>)) +   numpy.tile(numpy.arange(<span class="number">0</span>, numframes * frame_step, frame_step), (frame_len, <span class="number">1</span>)).T</span><br><span class="line">    indices = numpy.array(indices, dtype=numpy.int32)</span><br><span class="line">    frames = padsignal[indices]</span><br><span class="line">    win = numpy.tile(winfunc(frame_len), (numframes, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frames * win</span><br></pre></td></tr></table></figure>

<h3 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h3><p>DFT 从每一段加窗后的音频中分别提取出频域信息，计算方式为： </p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900876513.png" alt="Image" style="zoom: 50%;">

<p>其中xi为第i个长度为N的帧，K为DFT的长度（<strong>DFT 的一个实现方法是快速傅里叶变换（Fast Fourier Transform，FFT）， 可将时间复杂度从 O(N*N) 降为 O(Nlog2N)，但需要保证窗长 N 是 2 的指数，如果原窗长不满足此条件，一般音频信号 x 补充尾零，如 400 的窗长可扩展为 512)通过复数 X(k) 可计算第 k 个频段的幅度（Magnitude）和相位（Phase）</strong>，幅度之于频率的坐标图即是频谱（Spectrum）频谱的具体使用中，通常用 <img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image(3).png" alt="img" style="zoom:50%;">表示第 k 个频段的能量值（忽略了相位信息），记为 Power Spectrum（既是能量频谱，也是频谱的幂），并根据奈奎斯特频率（NyquistFrequency），只取其前半段（比如 512 的频数，取其前 512∗1/2+1）作为最终输出结果</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900936392.png" alt="Image" style="zoom:50%;">

<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900966423.png" alt="Image" style="zoom:67%;">

<p>python代码实现<br><strong>傅里叶变换长度NFFT的计算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_nfft</span><span class="params">(samplerate, winlen)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param samplerate: The sample rate of the signal we are working with, in Hz.</span></span><br><span class="line"><span class="string">    :param winlen: The length of the analysis window in seconds.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    window_length_samples = winlen * samplerate</span><br><span class="line">    nfft = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> nfft &lt; window_length_samples:</span><br><span class="line">    nfft *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nfft</span><br></pre></td></tr></table></figure>

<p><strong>计算帧中每帧的幅度值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">magspec</span><span class="params">(frames, NFFT)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param frames: the array of frames. Each row is a frame.</span></span><br><span class="line"><span class="string">    :param NFFT: the FFT length to use. If NFFT &gt; frame_len, the frames are zero-padded.</span></span><br><span class="line"><span class="string">    :returns: If frames is an NxD matrix, output will be Nx(NFFT/2+1).</span></span><br><span class="line"><span class="string">    Each row will be the magnitude spectrum of the corresponding frame.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> numpy.shape(frames)[<span class="number">1</span>] &gt; NFFT:</span><br><span class="line">    logging.warning(</span><br><span class="line">    <span class="string">'frame length (%d) is greater than FFT size (%d), frame will be truncated. Increase NFFT to avoid.'</span>,</span><br><span class="line">    numpy.shape(frames)[<span class="number">1</span>], NFFT)</span><br><span class="line">    complex_spec = numpy.fft.rfft(frames, NFFT)</span><br><span class="line">    <span class="keyword">return</span> numpy.absolute(complex_spec)</span><br></pre></td></tr></table></figure>

<p><strong>计算帧中每帧的功率谱</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powspec</span><span class="params">(frames, NFFT)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">:param frames: the array of frames. Each row is a frame.</span></span><br><span class="line"><span class="string">:param NFFT: the FFT length to use. If NFFT &gt; frame_len, the frames are zero-padded.</span></span><br><span class="line"><span class="string">:returns: If frames is an NxD matrix, output will be Nx(NFFT/2+1).</span></span><br><span class="line"><span class="string">Each row will be the power spectrum of the corresponding frame.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / NFFT * numpy.square(magspec(frames, NFFT))</span><br></pre></td></tr></table></figure>

<h3 id="梅尔滤波器组-Mel-Filter-Bank"><a href="#梅尔滤波器组-Mel-Filter-Bank" class="headerlink" title="梅尔滤波器组(Mel Filter Bank)"></a>梅尔滤波器组(Mel Filter Bank)</h3><p>人耳对不同频率的感知程度不一样，频率越高，敏感度较低，所以人耳的频域感知是非线性的，梅尔刻度（Mel Scale）正是刻画这种规律的， 它反映了人耳线性感知的梅尔频率（Mel Frequency） 与一般频率之间的关系。由一般频率 f 到梅尔刻度 Mel( f )的换算公式为：</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601901056718.png" alt="Image" style="zoom:67%;">

<p>梅尔刻度 Mel( f )到一般频率 f 的换算公式为：</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601901068825.png" alt="Image" style="zoom: 67%;">

<p>将频谱规划到梅尔刻度上，能有效促进语音识别系统的性能，实现方法是梅尔滤波器组（Mel Filter Bank）。 将上一部分输出的能量频谱通过如下图所示的三角滤波器组（Triangular Filter Bank） 得到梅尔频谱，计算方式与加窗类似，越往高频，滤波器窗口越大，窗口扩大的量级则与梅尔刻度一致。滤波器的个数就是梅尔频段的总数目，通常取为几十。梅尔频谱的能量数值取对数，最终得到的结果就是常说的 FBANK 特征。对数计算增强了特征的鲁棒性，且人类对能量强弱的感知是符合对数关系的。用于 DNN 训练时，FBANK 的维度就是梅尔滤波器的个数，常取 20 到 40 之间。     </p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601901086633.png" alt="Image" style="zoom:67%;">

<p>python代码实现</p>
<p><strong>将频率Hz转换为梅尔刻度mel</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hz2mel</span><span class="params">(hz)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2595</span> * numpy.log10(<span class="number">1</span> + hz / <span class="number">700.</span>)</span><br></pre></td></tr></table></figure>

<p><strong>将梅尔刻度mel转换为频率Hz</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mel2hz</span><span class="params">(mel)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">700</span> * (<span class="number">10</span> ** (mel / <span class="number">2595.0</span>) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>计算梅尔滤波器组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_filterbanks</span><span class="params">(nfilt=<span class="number">26</span>, nfft=<span class="number">512</span>, samplerate=<span class="number">16000</span>, lowfreq=<span class="number">0</span>, highfreq=None)</span>:</span></span><br><span class="line">    <span class="string">"""Compute a Mel-filterbank. The filters are stored in the rows, the columns correspond</span></span><br><span class="line"><span class="string">    to fft bins. </span></span><br><span class="line"><span class="string">    :param nfilt: the number of filters in the filterbank, default 20.</span></span><br><span class="line"><span class="string">    :param nfft: the FFT size. Default is 512.</span></span><br><span class="line"><span class="string">    :param samplerate: the sample rate of the signal we are working with, in Hz. Affects mel spacing.</span></span><br><span class="line"><span class="string">    :param lowfreq: lowest band edge of mel filters, default 0 Hz</span></span><br><span class="line"><span class="string">    :param highfreq: highest band edge of mel filters, default samplerate/2</span></span><br><span class="line"><span class="string">    :returns: A numpy array of size nfilt * (nfft/2 + 1) containing filterbank. Each row holds 1 filter.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 最高频率的计算</span></span><br><span class="line">    highfreq = highfreq <span class="keyword">or</span> samplerate / <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> highfreq &lt;= samplerate / <span class="number">2</span>, <span class="string">"highfreq is greater than samplerate/2"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute points evenly spaced in mels</span></span><br><span class="line">    lowmel = hz2mel(lowfreq)</span><br><span class="line">    highmel = hz2mel(highfreq)</span><br><span class="line">    <span class="comment"># 在时域中算出每个滤波器所对应的频率点</span></span><br><span class="line">    melpoints = numpy.linspace(lowmel, highmel, nfilt + <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 将频率舍入到最近的FFT区间</span></span><br><span class="line">    bin = numpy.floor((nfft + <span class="number">1</span>) * mel2hz(melpoints) / samplerate)</span><br><span class="line"></span><br><span class="line">    fbank = numpy.zeros([nfilt, nfft // <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, nfilt):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(bin[j]), int(bin[j + <span class="number">1</span>])):</span><br><span class="line">    fbank[j, i] = (i - bin[j]) / (bin[j + <span class="number">1</span>] - bin[j])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(bin[j + <span class="number">1</span>]), int(bin[j + <span class="number">2</span>])):</span><br><span class="line">    fbank[j, i] = (bin[j + <span class="number">2</span>] - i) / (bin[j + <span class="number">2</span>] - bin[j + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fbank</span><br></pre></td></tr></table></figure>

<h3 id="对数运算（log）、离散余弦变换（DCT）和升倒谱运算（lifter）"><a href="#对数运算（log）、离散余弦变换（DCT）和升倒谱运算（lifter）" class="headerlink" title="对数运算（log）、离散余弦变换（DCT）和升倒谱运算（lifter）"></a>对数运算（log）、离散余弦变换（DCT）和升倒谱运算（lifter）</h3><p>对上一部得到的feat（这也是由人类听觉引起的:我们听不到线性尺度上的响度。一般来说，要使一个声音的感知音量翻倍，我们需要投入8倍的能量。这意味着，如果一开始声音就很大，那么能量的巨大变化可能听起来并没有那么大的不同。这种压缩操作使我们的特性与人类实际听到的更接近。为什么是对数而不是立方根?对数允许我们使用倒谱平均减法，这是一种信道归一化技术）</p>
<p>接着对26个对数滤波器组feat进行离散余弦变换(DCT)得到26个倒谱系数，并且每一帧只保留前13个数据，每帧的这13个数称为梅尔倒谱系数（Mel Frequency Cepstral Coefficients）（因为我们的滤波器组都是重叠的，所以滤波器组能量彼此非常相关。 DCT可以对能量进行去相关，将包络与谐波分开）</p>
<p>最后进行升倒谱运算。默认升倒谱系数为22，这个过程做法是先产生一个拥有13个元素的一维数组llift，这13个元素的值lift[i]=1+(22 /2)<em>sin(pi</em>i/22)。得到这个数组lift之后，将上一步的feat和lift进行矩阵乘法，这其实就是mfcc参数的第一组。如果这组参数想要加上能量作为其表示方式，可以把每一行的的第一个元素numpy.log(energy)的每个值替换，即L[i][0] = F[i]。</p>
<p>python代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feat = numpy.log(feat)</span><br><span class="line">feat = dct(feat, type=<span class="number">2</span>, axis=<span class="number">1</span>, norm=<span class="string">'ortho'</span>)[:, :numcep] <span class="comment"># 封装好的DCT函数</span></span><br><span class="line">feat = lifter(feat, ceplifter)</span><br><span class="line"><span class="keyword">if</span> appendEnergy:</span><br><span class="line">    feat[:, <span class="number">0</span>] = numpy.log(energy)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lifter</span><span class="params">(cepstra, L=<span class="number">22</span>)</span>:</span></span><br><span class="line">    <span class="string">""" This has the effect of increasing the magnitude of the high frequency DCT coeffs.</span></span><br><span class="line"><span class="string">    :param cepstra: the matrix of mel-cepstra, will be numframes * numcep in size.</span></span><br><span class="line"><span class="string">    :param L: the liftering coefficient to use. Default is 22. L &lt;= 0 disables lifter.</span></span><br><span class="line"><span class="string">    """</span>    </span><br><span class="line">    <span class="keyword">if</span> L &gt; <span class="number">0</span>:</span><br><span class="line">        nframes, ncoeff = numpy.shape(cepstra)</span><br><span class="line">        n = numpy.arange(ncoeff)</span><br><span class="line">        lift = <span class="number">1</span> + (L / <span class="number">2.</span>) * numpy.sin(numpy.pi * n / L)</span><br><span class="line">        <span class="keyword">return</span> lift * cepstra</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># values of L &lt;= 0, do nothing</span></span><br><span class="line">        <span class="keyword">return</span> cepstra</span><br></pre></td></tr></table></figure>

<p>由此得到了MFCC的第一组特征参数</p>
<h3 id="计算动态特征（dynamic-feature）：Deltas-and-Delta-Deltas"><a href="#计算动态特征（dynamic-feature）：Deltas-and-Delta-Deltas" class="headerlink" title="计算动态特征（dynamic feature）：Deltas and Delta-Deltas"></a>计算动态特征（dynamic feature）：Deltas and Delta-Deltas</h3><p>（即MFCC的第二组和第三组特征参数）</p>
<p>MFCC特征向量只描述单个帧的功率谱包络线，但似乎语音也具有动态信息，即MFCC系数随时间的轨迹。结果表明，计算MFCC轨迹并将其附加到原始特征向量上可以大大提高ASR性能(如果我们有13个MFCC系数，我们还会得到13个deltas系数和13个delta-deltas系数，这将结合起来得到长度为39的特征向量)为了计算delta系数，使用以下公式：</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601901287830.png" alt="Image" style="zoom:67%;">

<p>其中dt为一个delta系数，c<em>t</em> 为上一步得到的第一组MFCC特征参数中的系数，N一般取2。Delta-Deltas系数的计算方法是一样的，但它们是由Deltas来计算的</p>
<p>python实现Deltas</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delta</span><span class="params">(feat, N)</span>:</span></span><br><span class="line">    <span class="string">"""Compute delta features from a feature vector sequence.</span></span><br><span class="line"><span class="string">    :param feat: A numpy array of size (NUMFRAMES by number of features) containing features.</span></span><br><span class="line"><span class="string">    Each row holds 1 feature vector.</span></span><br><span class="line"><span class="string">    :param N: For each frame, calculate delta features based on preceding and following N frames</span></span><br><span class="line"><span class="string">    :returns: A numpy array of size (NUMFRAMES by number of features) containing delta features.</span></span><br><span class="line"><span class="string">    Each row holds 1 delta feature vector.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> N &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'N must be an integer &gt;= 1'</span>)</span><br><span class="line">    NUMFRAMES = len(feat)</span><br><span class="line">    <span class="comment"># print(NUMFRAMES)</span></span><br><span class="line">    denominator = <span class="number">2</span> * sum([i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>)])</span><br><span class="line">    delta_feat = numpy.empty_like(feat)</span><br><span class="line">    padded = numpy.pad(feat, ((N, N), (<span class="number">0</span>, <span class="number">0</span>)), mode=<span class="string">'edge'</span>) <span class="comment"># padded version of feat</span></span><br><span class="line">    print(<span class="string">"padded的维度："</span>, end=<span class="string">""</span>)</span><br><span class="line">    print(padded.shape)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(NUMFRAMES):</span><br><span class="line">        <span class="comment"># [t : t+2*N+1] == [(N+t)-N : (N+t)+N+1]</span></span><br><span class="line">        delta_feat[t] = numpy.dot(numpy.arange(-N, N + <span class="number">1</span>),</span><br><span class="line">        padded[(N + t) - N: (N + t) + N + <span class="number">1</span>]) / denominator</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delta_feat</span><br></pre></td></tr></table></figure>

<p>以上得到了MFCC的第二组和第三组特征参数</p>
]]></content>
      <categories>
        <category>语音信号</category>
      </categories>
      <tags>
        <tag>语音信号</tag>
      </tags>
  </entry>
  <entry>
    <title>音频信号分帧</title>
    <url>/2019/10/05/%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%88%86%E5%B8%A7/</url>
    <content><![CDATA[<p>什么是分帧？通俗地理解就是，<strong>加窗处理</strong>、<strong>分段处理</strong>。随着窗口的往右（假设向右代表时间向前）推移，对加窗后的信号逐步展开处理。</p>
<p><strong>分帧的三个要素</strong>：</p>
<ol>
<li><p>窗口长度是多少wlen（window length）。(帧长一般取为 20 ~ 50 毫秒)</p>
</li>
<li><p>每次窗口往右移动多长，即增量increment，或步长step。(常见的取法是取为帧长的一半，或者固定取为 10 毫秒)</p>
</li>
<li><p>窗口选什么类型。时域上的加窗就是把原始信号x(t)与窗口w(t)相乘，频域就是对应的卷积。 不同的窗函数有不同的性质。常见的有矩形窗、三角窗、Hanning窗、<strong>Hamming窗</strong>、Blackman窗、Kaiser窗 …… (加窗的目的是让一帧信号的幅度在两端渐变到 0。渐变对傅里叶变换有好处，可以提高变换结果（即频谱）的分辨率)</p>
<p><img src="/2019/10/05/%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%88%86%E5%B8%A7/v2-29273fde835815754c6e7369f463aa10_hd.jpg" alt="v2-29273fde835815754c6e7369f463aa10_hd"></p>
</li>
</ol>
<p>对一帧信号做傅里叶变换，得到的结果叫<strong>频谱</strong></p>
<p><img src="/2019/10/05/%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%88%86%E5%B8%A7/v2-05197addda7c2019a388f5b7e9e94f04_r.jpg" alt="v2-05197addda7c2019a388f5b7e9e94f04_r"></p>
<p>语音的频谱，常常呈现出「<strong>精细结构</strong>」和「<strong>包络</strong>」两种模式。「精细结构」就是蓝线上的一个个小峰，它们在横轴上的间距就是基频，它体现了语音的音高——峰越稀疏，基频越高，音高也越高。「包络」则是连接这些小峰峰顶的平滑曲线（红线），它代表了口型，即发的是哪个音。包络上的峰叫<strong>共振峰，</strong>图中能看出四个，分别在 500、1700、2450、3800 赫兹附近。</p>
<p><strong>代码实现</strong></p>
<p>帧数 Nframe = floor( (length(x) - wlen) / inc) + 1</p>
<p>x：原始音频型号，wlen：每一帧的长度，inc：相邻帧的间隔</p>
<p>MATLAB代码</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Nframe = <span class="built_in">floor</span>( (<span class="built_in">length</span>(x) - wlen) / inc) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:Nframe </span><br><span class="line">    idx = (<span class="number">1</span>:wlen) + (k<span class="number">-1</span>) * nstep;</span><br><span class="line">    x_frame = x(idx); </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>最后，分帧以后，应该把帧的序号对应上时间frame-to-time的函数如下:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">frameTime</span>=<span class="title">frame2time</span><span class="params">(frameNum,framelen,inc,fs)</span> </span></span><br><span class="line"><span class="comment">% 分帧后计算每帧对应的时间 </span></span><br><span class="line">frameTime=(((<span class="number">1</span>:frameNum)<span class="number">-1</span>)*inc+framelen/<span class="number">2</span>)/fs; <span class="comment">%fs为采样率</span></span><br></pre></td></tr></table></figure>

<p>而给定一个时刻，想求得其对应的帧的代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% t0 特定时刻 </span></span><br><span class="line">frame_idx=<span class="built_in">fix</span>((t0*fs-wlen)/nstep +<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>语音信号</category>
      </categories>
      <tags>
        <tag>语音信号</tag>
      </tags>
  </entry>
</search>
