<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMU-15-445 Project1-任务1：可扩展的哈希表</title>
    <url>/2019/12/05/CMU-15-445-Project1-%E4%BB%BB%E5%8A%A11/</url>
    <content><![CDATA[<h2 id="可扩展哈希表的介绍"><a href="#可扩展哈希表的介绍" class="headerlink" title="可扩展哈希表的介绍"></a>可扩展哈希表的介绍</h2><p><img src="/2019/12/05/CMU-15-445-Project1-%E4%BB%BB%E5%8A%A11/2.png" alt="2"></p>
<p><img src="/2019/12/05/CMU-15-445-Project1-%E4%BB%BB%E5%8A%A11/1.png" alt="1"></p>
<p><img src="/2019/12/05/CMU-15-445-Project1-%E4%BB%BB%E5%8A%A11/3.png" alt="3"></p>
<p><img src="/2019/12/05/CMU-15-445-Project1-%E4%BB%BB%E5%8A%A11/4.png" alt="4"></p>
<h2 id="可扩展哈希表的实现"><a href="#可扩展哈希表的实现" class="headerlink" title="可扩展哈希表的实现"></a>可扩展哈希表的实现</h2><h3 id="可扩展哈希表类的基类HashTable"><a href="#可扩展哈希表类的基类HashTable" class="headerlink" title="可扩展哈希表类的基类HashTable"></a><strong>可扩展哈希表类的基类HashTable</strong></h3><p>有三个虚函数Find(), Remove(), Insert()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  HashTable() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~HashTable() &#123;&#125;</span><br><span class="line">  <span class="comment">// lookup and modifier</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K &amp;key, V &amp;value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> K &amp;key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> K &amp;key, <span class="keyword">const</span> V &amp;value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="可扩展哈希表类ExtendibleHash的实现"><a href="#可扩展哈希表类ExtendibleHash的实现" class="headerlink" title="可扩展哈希表类ExtendibleHash的实现"></a>可扩展哈希表类ExtendibleHash的实现</h3><p>可扩展哈希表类一个内部结构体Bucket，Bucket内部使用map存储键值对，Bucket内用localDepth记录桶的局部深度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendibleHash</span> :</span> <span class="keyword">public</span> HashTable&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> &#123;</span></span><br><span class="line">            explicit Bucket(int depth):localDepth(depth) &#123;&#125;;</span><br><span class="line">            <span class="keyword">int</span> localDepth;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">map</span>&lt;K, V&gt; items;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// constructor</span></span><br><span class="line">  ExtendibleHash(<span class="keyword">size_t</span> <span class="built_in">size</span>);</span><br><span class="line">  <span class="comment">// helper function to generate hash addressing</span></span><br><span class="line">  <span class="keyword">size_t</span> HashKey(<span class="keyword">const</span> K &amp;key) <span class="keyword">const</span>;</span><br><span class="line">  <span class="comment">// helper function to get global &amp; local depth</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">GetGlobalDepth</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">GetLocalDepth</span><span class="params">(<span class="keyword">int</span> bucket_id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">GetNumBuckets</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K &amp;key, V &amp;value)</span> override</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> K &amp;key)</span> override</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> K &amp;key, <span class="keyword">const</span> V &amp;value)</span> override</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getBucketIndex</span><span class="params">(<span class="keyword">const</span> K &amp;key)</span> <span class="keyword">const</span></span>; <span class="comment">// 获取桶的索引</span></span><br><span class="line">  <span class="keyword">int</span> globalDepth;  <span class="comment">// 全局深度</span></span><br><span class="line">  <span class="keyword">size_t</span> bucketMaxSize; <span class="comment">// 桶内所能容纳元素的最大个数</span></span><br><span class="line">  <span class="keyword">int</span> numBuckets; <span class="comment">// 桶的个数</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bucket&gt;&gt; bucketTable; <span class="comment">//用vector存储指向Bucket的指针</span></span><br><span class="line">  <span class="built_in">std</span>::mutex mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数的实现"><a href="#构造函数的实现" class="headerlink" title="构造函数的实现"></a>构造函数的实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">ExtendibleHash&lt;K, V&gt;::ExtendibleHash(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">    :globalDepth(<span class="number">0</span>), bucketMaxSize(<span class="built_in">size</span>), numBuckets(<span class="number">0</span>) &#123;</span><br><span class="line">    bucketTable.push_back(<span class="built_in">std</span>::make_shared&lt;Bucket&gt;(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashKey函数的实现"><a href="#HashKey函数的实现" class="headerlink" title="HashKey函数的实现"></a>HashKey函数的实现</h3><p> 计算输入输入键的哈希地址 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">size_t</span> ExtendibleHash&lt;K, V&gt;::HashKey(<span class="keyword">const</span> K &amp;key) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::hash&lt;K&gt;&#123;&#125;(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一些辅助函数"><a href="#一些辅助函数" class="headerlink" title="一些辅助函数"></a>一些辅助函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">int</span> ExtendibleHash&lt;K, V&gt;::GetGlobalDepth() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> globalDepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">int</span> ExtendibleHash&lt;K, V&gt;::GetLocalDepth(<span class="keyword">int</span> bucket_id) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> bucketTable[bucket_id]-&gt;localDepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">int</span> ExtendibleHash&lt;K, V&gt;::GetNumBuckets() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> numBuckets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getBucketIndex函数的实现"><a href="#getBucketIndex函数的实现" class="headerlink" title="getBucketIndex函数的实现"></a>getBucketIndex函数的实现</h3><p>通过key获取桶在BucketTable中的index</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">int</span> ExtendibleHash&lt;K, V&gt;::getBucketIndex(<span class="keyword">const</span> K &amp;key) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> HashKey(key) &amp; ((<span class="number">1</span> &lt;&lt; globalDepth) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Find函数的实现"><a href="#Find函数的实现" class="headerlink" title="Find函数的实现"></a>Find函数的实现</h3><p>寻找与key对应的value，如果找到了将值存入输入参数value中 ，返回true，否则返回false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">bool</span> ExtendibleHash&lt;K, V&gt;::Find(<span class="keyword">const</span> K &amp;key, V &amp;value) &#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> index = getBucketIndex(key);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bucket&gt; bucket = bucketTable[index];</span><br><span class="line">  <span class="keyword">if</span> (bucket != <span class="literal">nullptr</span> &amp;&amp; bucket-&gt;items.<span class="built_in">find</span>(key) != bucket-&gt;items.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    value = bucket-&gt;items[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Remove函数的实现"><a href="#Remove函数的实现" class="headerlink" title="Remove函数的实现"></a>Remove函数的实现</h3><p>删除hashtable中的键值对&lt;key, value&gt;，删除成功返回true，否则返回false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">bool</span> ExtendibleHash&lt;K, V&gt;::Remove(<span class="keyword">const</span> K &amp;key) &#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> index = getBucketIndex(key);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bucket&gt; bucket = bucketTable[index];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bucket == <span class="literal">nullptr</span> || bucket-&gt;items.<span class="built_in">find</span>(key) == bucket-&gt;items.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  bucket-&gt;items.erase(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Insert函数的实现"><a href="#Insert函数的实现" class="headerlink" title="Insert函数的实现"></a>Insert函数的实现</h3><p>插入&lt;key, value&gt;键值对到hashtable中，如果桶溢出，增加global depth</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> ExtendibleHash&lt;K, V&gt;::Insert(<span class="keyword">const</span> K &amp;key, <span class="keyword">const</span> V &amp;value) &#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> index = getBucketIndex(key);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bucket&gt; targetBucket = bucketTable[index];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (targetBucket-&gt;items.<span class="built_in">size</span>() == bucketMaxSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (targetBucket-&gt;localDepth == globalDepth) &#123;</span><br><span class="line">      <span class="keyword">size_t</span> length = bucketTable.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        bucketTable.push_back(bucketTable[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      globalDepth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; targetBucket-&gt;localDepth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> zeroBucket = <span class="built_in">std</span>::make_shared&lt;Bucket&gt;(targetBucket-&gt;localDepth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> oneBucket = <span class="built_in">std</span>::make_shared&lt;Bucket&gt;(targetBucket-&gt;localDepth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : targetBucket-&gt;items) &#123;</span><br><span class="line">      <span class="keyword">size_t</span> hashkey = HashKey(item.first);</span><br><span class="line">      <span class="keyword">if</span> (hashkey &amp; mask) &#123;</span><br><span class="line">        oneBucket-&gt;items.insert(item);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zeroBucket-&gt;items.insert(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; bucketTable.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bucketTable[i] == targetBucket) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; mask) &#123;</span><br><span class="line">          bucketTable[i] = oneBucket;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          bucketTable[i] = zeroBucket;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index = getBucketIndex(key);</span><br><span class="line">    targetBucket = bucketTable[index];</span><br><span class="line">  &#125; <span class="comment">//end while</span></span><br><span class="line"></span><br><span class="line">  targetBucket-&gt;items[key] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CMU-15-445</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确地删除vector中符合条件的某元素</title>
    <url>/2019/11/20/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%88%A0%E9%99%A4vector%E4%B8%AD%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9F%90%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>比如，有一个vector&lt; int &gt; nums = {1, 2, 2, 2, 2, 3, 5}，要求删除nums中所有值为2的元素 </p>
<h3 id="一个符合直觉的错误实现"><a href="#一个符合直觉的错误实现" class="headerlink" title="一个符合直觉的错误实现"></a>一个符合直觉的错误实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123; </span><br><span class="line">        nums.erase(it); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码循环遍历nums中的每个元素，判断是否为2，是的话则erase掉。看起来好像没什么问题，但是实际上已经造成了bug。这段代码的执行完成后，<strong>nums存储的元素是{1, 2, 2, 3, 5}</strong>，值为2的元素并没有被全部清除掉。</p>
<p>为什么会出现这个结果呢？原因就是<strong>迭代器失效</strong> ：在第一个2被erase掉的时候，it迭代器已经失效了，它指向了被删除元素的下一个元素，用它来继续遍历vector就会漏掉被删除元素后面的第一个元素，导致2没有被完全清除。</p>
<h3 id="第一种正确实现：让it指向下一个元素"><a href="#第一种正确实现：让it指向下一个元素" class="headerlink" title="第一种正确实现：让it指向下一个元素"></a>第一种正确实现：让it指向下一个元素</h3><p><strong>erase函数的返回值是指向当前被删除元素的下一个元素的迭代器</strong>。那么我们把这个返回值赋值给it继续遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">        it = nums.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种正确实现：erase-remove"><a href="#第二种正确实现：erase-remove" class="headerlink" title="第二种正确实现：erase-remove"></a>第二种正确实现：erase-remove</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    nums.erase(<span class="built_in">remove</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(), <span class="number">2</span>), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>erase</strong>用来删除一段区间的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>remove</strong>  <strong>移除但不删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它<strong>并不真正从容器中删除那些元素</strong>（换句话说容器的大小不变），<strong>而是将每一个不与value相等（也就是我们不打算移除）的元素轮番赋值给first之后的空间</strong>。</p>
<p>例如：{0，1，0，2，0，3，0，4}，用remove移除值为0的元素，执行结果为{1，2，3，4，0，3，0，4}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>) &#123;</span></span><br><span class="line">    first = <span class="built_in">find</span>(first, last, value);</span><br><span class="line">    ForwardIterator next = first;</span><br><span class="line">    <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> remove_copy(++next, last, first, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove_copy</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">IntputIt</span> <span class="title">first</span>,<span class="title">IntputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它并不真正从容器中删除那些元素（换句话说容器的大小不变）,而是<strong>将结果复制到一个以result标示起始位置的容器上，新容器可以和原容器重叠。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">OutputIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIt</span> <span class="title">remove_copy</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first!=last;++first)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*first!=value)&#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









































]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C库函数memcpy()和memmove()的区别</title>
    <url>/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>memcpy( )和memmove( )都是C语言中的库函数，在头文件string.h中。</p>
<p>其作用是从src内存中拷贝n个字节到dest内存区域中，原型分别如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="memcpy-和memmove-的区别"><a href="#memcpy-和memmove-的区别" class="headerlink" title="memcpy()和memmove()的区别"></a>memcpy()和memmove()的区别</h3><p>他们的作用是一样的，<strong>唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。</strong></p>
<p><img src="/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/memory.png" alt="memory"></p>
<h3 id="memcpy-函数的实现"><a href="#memcpy-函数的实现" class="headerlink" title="memcpy()函数的实现"></a>memcpy()函数的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    <span class="keyword">char</span> *s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        *tmp++ = *s_src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="memmove-实现函数"><a href="#memmove-实现函数" class="headerlink" title="memmove()实现函数"></a>memmove()实现函数</h3><p>memmove就是针对第二种内存覆盖情形，对memcpy进行了改进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memmove</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s_dst;</span><br><span class="line">    <span class="keyword">char</span>* s_src;</span><br><span class="line">    s_dst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">if</span>(s_dst&gt;s_src &amp;&amp; (s_src+n&gt;s_dst)) &#123;      <span class="comment">//第二种内存覆盖的情形。</span></span><br><span class="line">        <span class="comment">// 从后往前复制，防止出现内存覆盖的情形</span></span><br><span class="line">        s_dst = s_dst+n<span class="number">-1</span>;</span><br><span class="line">        s_src = s_src+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst-- = *s_src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst++ = *s_src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
