<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>demo6</title>
    <url>/2020/09/30/demo6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>demo5</title>
    <url>/2020/09/30/demo5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>demo4</title>
    <url>/2020/09/30/demo4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Redis数据结构之字典</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<p>字典是一种用于保存键值对（key-value pair）的抽象数据结构，在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。</p>
<p>字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。</p>
<hr>
<h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p><strong>Redis的字典使用哈希表作为底层实现</strong>，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对</p>
<p>Redis字典所使用的哈希表结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>table属性是一个<strong>数组</strong>，数组中的每个元素都指向一个dictEntry结构的指针，每个dictEntry结构保存着一个键值对。</p>
<p>size属性记录了哈希表的大小，即table数组的大小，而used属性则记录了哈希表目前已有键值对的数量。</p>
<p>sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上</p>
<p>下图展示了一个大小为4的空哈希表：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/image-20201002173245108.png" alt="image-20201002173245108" style="zoom:80%;">

<h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存一个键值对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>key属性保持着键值对中的键，而v属性则保存着键值对中的值，其中键值对中的值可以是一个指针，或者是一个整数。</p>
<p>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，来解决<strong>键冲突问题</strong>（以链表的方式解决冲突问题）。</p>
<p>如下图表示一个完成的哈希表：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/image-20201002173545433.png" alt="image-20201002173545433" style="zoom:80%;">

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>type属性和privdata属性是针对不同类型的键值对，而创建多态字典而设置的</p>
<ul>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一组用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同类型的特定函数</li>
<li>privadata属性则保存了需要传给那些类型特定函数的可选参数</li>
</ul>
<p><strong>ht属性是一个包含了两个项的数组，数组中每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，而ht[1]哈希表只对ht[0]哈希表进行<code>rehash</code>时使用</strong></p>
<p>另一个与rehash有关的就是rehashidx属性，它积累了rehash目前的进度，如果没有进行rehash，则它的值为-1</p>
<p>下图为一个普通状态下的字典结构：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/image-20201002173956795.png" alt="image-20201002173956795" style="zoom: 75%;">

<hr>
<h3 id="哈希算法和哈希冲突"><a href="#哈希算法和哈希冲突" class="headerlink" title="哈希算法和哈希冲突"></a>哈希算法和哈希冲突</h3><p>将一个新的键值对添加到字典里面的时候，程序需要先根据键值对上面的键来计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希数组的指定索引上面。</p>
<p>Redis计算哈希值和索引值的方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment">// 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p><em>Redis使用MurmurHash2算法来计算键的哈希值</em></p>
<p>Redis哈希表使用<strong>链地址法</strong>来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next构成一个单向链表，被分配到同一个索引上的节点可以用这个单向链表连接起来，从而解决键冲突问题</p>
<p>因为dictEntry节点组成的链表没有指向链表表尾的指针，为了考虑速度，<strong>程序总是将新节点添加到链表的表头位置（这样添加节点的时间复杂度为O(1)</strong></p>
<hr>
<h3 id="rehash和渐进式rehash"><a href="#rehash和渐进式rehash" class="headerlink" title="rehash和渐进式rehash"></a>rehash和渐进式rehash</h3><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a><strong>rehash</strong></h4><p>随着操作的不断进行，哈希表保存的键值对会逐渐增多或减少，为了让哈希表<strong>负载因子</strong>维持在一个合理范围之内，当哈希表保存的键值对太多或太少时，程序要对哈希表的大小进行相应的扩展或收缩。</p>
<p>Redis对字典的哈希表执行rehash的步骤如下：</p>
<ol>
<li>为字典的ht[1]哈希表分配空间，这个空间大小取决于要执行的操作<ul>
<li>如果执行的是扩展操作，则ht[1]的大小为第一个大于等于等于ht[0].used*2的2^n</li>
<li>如果执行的收缩操作，则ht[1]的大小为第一个大于等于ht[0].used的2^n</li>
</ul>
</li>
<li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]的指定位置上</li>
<li>当ht[0]包含的所有键值对都迁移到ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备</li>
</ol>
<p><strong>哈希表的扩展与收缩</strong></p>
<p>当以下条件中任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p>
<ul>
<li>服务器目前没有执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子大于等于1</li>
<li>服务器正在执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子大于等于5</li>
</ul>
<p>另一方面，当哈希表负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>Redis中的rehash动作并不是一次性、集中式完成的，而是<strong>分多次、渐进式的完成的。</strong></p>
<p>这样做的目的是，如果服务器中包含很多键值对，要一次性的将这些键值对全部rehash到ht[1]的话，庞大的计算量可能导致服务器在一段时间内停止服务于。</p>
<p>为了避免这种影响，Redis采用了<strong>渐进式Redis</strong>：</p>
<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它置为0，表示rehash工作开始</li>
<li>在rehash进行期间，<strong>每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]中</strong>，当rehash工作完成之后，程序将rehashidx属性的值+1</li>
<li>随着字典操作的不断进行，最终在某个时间点上，ht[0]的所有键值对都被rehash到ht[1]上，这时将rehashidx属性设为-1，表示rehash完成</li>
</ol>
<p><strong>渐进式rehash</strong>的好处在于其采取<strong>分而治之</strong>的方式，将rehash键值对所需要的计算工作均摊到字典的<strong>每个</strong>添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量</p>
<p><strong>渐进式rehash执行期间的哈希表操作</strong></p>
<p>因为在渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找、更新等操作都是在两个表上进行的。</p>
<p>例如，<strong>查找</strong>操作会先在ht[0]上进行，如果没找到再在ht[1]上进行。<strong>添加</strong>操作的键值对会一律保存到ht[1]中，这一措施保证ht[0]包含的键值对只会减少不会增加。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之链表</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表在 Redis 中的应用非常广泛， 比如列表键的底层实现之一就是链表： 当一个列表键包含了数量比较多的元素， 又或者列表中包含的元素都是比较长的字符串时， Redis 就会使用链表作为列表键的底层实现。</p>
<p>除了链表键之外， 发布与订阅、慢查询、监视器等功能也用到了链表， Redis 服务器本身还使用链表来保存多个客户端的状态信息， 以及使用链表来构建客户端输出缓冲区（output buffer）</p>
<p>Redis链表为双向无环链表</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/image-20201002171439480.png" alt="image-20201002171439480" style="zoom: 80%;">

<p>如图所示，Redis使用一个listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="comment">// 前置节点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span> </span><br><span class="line">	<span class="comment">// 后置节点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> </span><br><span class="line">	<span class="comment">// 节点的值 </span></span><br><span class="line">	<span class="keyword">void</span> *value; </span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>同时Redis为了方便的操作链表，提供了一个<strong>list结构</strong>来持有链表。如下图所示</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/image-20201002171607721.png" alt="image-20201002171607721" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Redis链表结构其主要特性如下:</strong></p>
<ul>
<li>双向：链表节点带有prev和next指针，获取某个节点的前驱、后继节点的时间复杂度为0(1)</li>
<li>无环: 链表为非循环链表，表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</li>
<li>带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1)</li>
<li>带链表长度计数器：通过list结构的len属性获取节点数量的时间复杂度为O(1)</li>
<li>多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之SDS</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</url>
    <content><![CDATA[<p> 字符串在Redis中使用非常广泛，在Redis中，所有的数据都保存在字典（Map）中，而字典的键就是字符串类型，并且对于很大一部分字典值数据也是又字符串组成的。以下是SDS的具体存储结构：</p>
<p><img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/202205_cXnQ_2831721.png" alt="img"></p>
<p>从图中可以看出，SDS的属性有三个：len、free和buf数组：</p>
<ul>
<li>len字段是用来保存SDS字符串中所包含字符数目的</li>
<li>free字段则是用来保存buf数组中空余的部分的长度的</li>
<li>buf数组则是实际用来保存字符串的</li>
</ul>
<p>比如如下结构保存了“Hello World！”这个字符串：</p>
<p><img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/204859_FBGP_2831721.png" alt="img"></p>
<p>这里需要注意的是，SDS和C字符串一样，需要在字符串结尾加上一个’\0’表示该字符串的结束（可以直接使用C字符串库里面的函数）</p>
<p><strong>Redis使用SDS结构而不用c字符串保存字符串的原因有如下几点</strong>：</p>
<ol>
<li><strong>常数复杂度获取字符串长度</strong><ul>
<li>通过读取SDS对象的len属性的值我们可以使用O(1)获取SDS对象保存的字符串长度</li>
<li>在c字符串中，我们必须对整个数组进行遍历从而获取字符串的长度，其时间复杂度为O(N)</li>
</ul>
</li>
<li><strong>杜绝缓冲区溢出</strong><ul>
<li>在C字符串中，比如char *strcat(char *dest, const char *src)函数将src连接到dest的末尾，但是c字符串假定dest数组中有足够的空余空间来保存src数组，如果dest数组长度不够就会造成缓冲区溢出</li>
<li>在SDS对象中也提供了类似的函数SDS SDScat(SDS s, const char *t)和SDS SDScatSDS(SDS s, const SDS t)，这两个函数在调用之前会检查目标SDS对象s中free属性是否能够保存要连接的字符串的长度，如果不够，就会对目标SDS对象扩容，这就保证了SDS对象不会造成缓冲区溢出</li>
</ul>
</li>
<li><strong>减少修改字符串时内存重分配的次数</strong><ul>
<li>对于c字符串，每次对其进行修改都需要进行一次空间分配和复制操作，否则会造成缓冲区溢出和内存泄漏</li>
<li>在对SDS进行修改的时候，Redis可以通过<strong>空间预分配</strong>和<strong>惰性空间释放</strong>来保证后续对SDS对象的频繁修改而不会造成SDS对象的buf数组经常分配空间<ol>
<li>空间预分配：对于追加操作来说，Redis不仅会开辟空间至够用而且还会预分配未使用的空间(free)来用于下一次操作。至于未使用的空间(free)的大小则由修改后的字符串长度决定<ul>
<li>当修改后的字符串长度len &lt; 1M,则会分配与len相同长度的未使用的空间</li>
<li>当修改后的字符串长度len &gt;= 1M,则会分配1M长度的未使用的空间</li>
</ul>
</li>
<li>惰性空间回收：在对SDS的字符串进行缩短操作的时候，程序并不会立刻使用内存重分配来回收缩短之后多出来的字节，而是使用free属性将这些字节的数量记录下来等待将来使用</li>
</ol>
</li>
</ul>
</li>
<li><strong>二进制安全</strong><ul>
<li>对于c字符串，由于其判断是否结束的标志是从字符串开始到结尾碰到的第一个“\0”字符，这就限制了c字符串不能保存像图片、音频、视频、压缩文件等二进制保存的内容</li>
<li>对于SDS对象，由于判断其是否结束的标志是其len属性，也就是说无论在len长度内，buf数组中是否包含“\0”都不影响Redis判断其是否结束</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th align="center">C字符串</th>
<th align="center">SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">获取字符串长度的复杂度为O(N)</td>
<td align="center">获取字符串长度的复杂度为O(1)</td>
</tr>
<tr>
<td align="center">API是不安全的，可能会造成缓冲区溢出</td>
<td align="center">API是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td align="center">修改字符串长度N次必然需要执行N次内存分配操作</td>
<td align="center">修改字符串长度N次最多需要执行N次内存分配操作</td>
</tr>
<tr>
<td align="center">只能保存文本数据</td>
<td align="center">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td align="center">可以使用所有&lt;string.h&gt;库中的函数</td>
<td align="center">可以使用一部分&lt;string.h&gt;库中的函数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库缓冲池</title>
    <url>/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/</url>
    <content><![CDATA[<p>应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在<strong>缓存</strong>(cache)里，避免每次都去访问数据库。操作系统会有<strong>缓冲池</strong>(buffer pool)机制，避免每次都访问磁盘，以加速数据的访问。MySQL作为一个存储系统，同样具有<strong>缓冲池</strong>(buffer pool)机制，以避免每次查询数据都进行磁盘IO</p>
<p><strong>InnoDB的缓冲池缓存什么？有什么用？</strong></p>
<p>缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用。</p>
<p><strong>如何管理与淘汰缓冲池，使得性能最大化呢？</strong></p>
<p>在介绍具体细节之前，先介绍下“预读”的概念。</p>
<p><strong>什么是预读？</strong>磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。 </p>
<p><strong>预读为什么有效？</strong>数据访问，通常都遵循“集中读写”的原则，使用一些数据，大概率会使用附近的数据，这就是所谓的“局部性原理”，它表明提前加载是有效的，确实能够减少磁盘IO。 </p>
<p><strong>按页(4K)读取，和InnoDB的缓冲池设计有啥关系？</strong>（1）磁盘访问按页读取能够提高性能，所以缓冲池一般也是按页缓存数据；（2）预读机制启示了我们，能把一些“可能要访问”的页提前加入缓冲池，避免未来的磁盘IO操作；</p>
<p><strong>InnoDB是以什么算法，来管理这些缓冲页呢？</strong>最容易想到的，就是LRU(Least recently used)。</p>
<p><strong>传统的LRU是如何进行缓冲页管理？</strong>最常见的玩法是，把入缓冲池的页放到LRU的头部，作为最近访问的元素，从而最晚被淘汰。这里又分两种情况：（1）<strong>页已经在缓冲池里</strong>，那就只做“移至”LRU头部的动作，而没有页被淘汰；（2）<strong>页不在缓冲池里</strong>，除了做“放入”LRU头部的动作，还要做“淘汰”LRU尾部页的动作；</p>
<p>虽然传统的LRU缓冲池算法十分直观，但这里有两个问题：（1）<strong>预读失效</strong>；（2）<strong>缓冲池污染</strong></p>
<p><strong>什么是预读失效？</strong>由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效。</p>
<p><strong>如何对预读失效进行优化？</strong>要优化预读失效，思路是：（1）让预读失败的页，停留在缓冲池LRU里的时间尽可能短；（2）让真正被读取的页，才挪到缓冲池LRU的头部；以保证，真正被读取的热数据留在缓冲池里的时间尽可能长。</p>
<p><strong>具体方法是</strong>：</p>
<ol>
<li>将LRU分为两个部分：新生代(new sublist)老生代(old sublist)</li>
<li>新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)</li>
<li>新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：如果数据真正被读取（预读成功），才会加入到新生代的头部如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池</li>
</ol>
<p><strong>举个例子，整个缓冲池LRU如图：</strong></p>
<p>（1）整个LRU长度是10（2）前70%是新生代（3）后30%是老生代（4）新老生代首尾相连</p>
<img src="/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/Image.png" alt="Image" style="zoom: 95%;">

<p>假如有一个页号为50的新页被预读加入缓冲池：</p>
<ol>
<li>50只会从老生代头部插入，老生代尾部（也是整体尾部）的页会被淘汰掉；</li>
<li>假设50这一页不会被真正读取，即预读失败，它将比新生代的数据更早淘汰出缓冲池；</li>
</ol>
<img src="/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/Image-1594741614324.png" alt="Image" style="zoom:95%;">

<p>假如50这一页立刻被读取到，例如SQL访问了页内的行row数据：</p>
<ol>
<li>它会被立刻加入到新生代的头部；</li>
<li>新生代的页会被挤到老生代，此时并不会有页面被真正淘汰；</li>
</ol>
<img src="/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/Image-1594747637932.png" alt="Image" style="zoom:95%;">

<p><strong>老生代改进版LRU仍然解决不了缓冲池污染的问题。</strong></p>
<p><strong>什么是MySQL缓冲池污染？</strong></p>
<p>当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。 </p>
<p>例如，有一个数据量较大的用户表，当执行：select * from user where name like “%foo%”，虽然结果集可能只有少量数据，但这类like不能命中索引，必须全表扫描，就需要访问大量的页：</p>
<ol>
<li>把页加到缓冲池（插入老生代头部）；</li>
<li>从页里读出相关的row（插入新生代头部）；</li>
<li>row里的name字段和字符串foo进行比较，如果符合条件，加入到结果集中；</li>
<li>直到扫描完所有页中的所有row</li>
</ol>
<p>如此一来，所有的数据页都会被加载到新生代的头部，但只会访问一次，真正的热数据被大量换出。</p>
<p><strong>怎么处理这类扫码大量数据导致的缓冲池污染问题呢？</strong></p>
<p>MySQL缓冲池加入了一个“<strong>老生代停留时间窗口</strong>”的机制：</p>
<ol>
<li>假设T=老生代停留时间窗口；</li>
<li>插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部</li>
<li>只有满足“<strong>被访问”</strong>并且“<strong>在老生代停留时间”大于T</strong>，才会被放入新生代头部；</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li>缓冲池(buffer pool)是一种<strong>常见的降低磁盘访问的机制；</strong></li>
<li>缓冲池通常<strong>以页(page)为单位缓存数据</strong>；</li>
<li>缓冲池的<strong>常见管理算法是LRU</strong>，memcache，OS，InnoDB都使用了这种算法；</li>
<li>InnoDB对普通LRU进行了优化：<ul>
<li>将缓冲池分为<strong>老生代和新生代</strong>，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，<strong>以解决预读失效的问题</strong></li>
<li><strong>页被访问</strong>，且在老生代<strong>停留时间超过配置阈值</strong>的，才进入新生代，<strong>以解决批量数据访问，大量热数据淘汰的问题</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>前置++和后置++</title>
    <url>/2020/03/07/%E5%89%8D%E7%BD%AE++%E5%92%8C%E5%90%8E%E7%BD%AE++/</url>
    <content><![CDATA[<p>++a表示取a的地址，增加它的内容，然后把值放在寄存器中；</p>
<p>a++表示取a的地址，把它的值装入寄存器，然后增加内存中的a的值；</p>
<p><strong>前置++和后置++的重载</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Age &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Age <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        Age tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Age a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码，我们可以看出前置++和后置++，有4点不同：</p>
<ol>
<li>返回类型不同</li>
<li>形参不同</li>
<li>代码不同</li>
<li>效率不同</li>
</ol>
<p><strong>1. 返回值类型的区别</strong></p>
<p>前置++的返回类型是Age&amp;，后置++的返回类型const Age。这意味着，前置++返回的是左值，后置++返回的是右值</p>
<p>左值和右值，决定了前置++和后置++的用法</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">int</span> <span class="comment">main()</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">Age</span> <span class="comment">a;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span>    <span class="comment">(a</span>++<span class="comment">)</span>++<span class="comment">;</span>  <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment"></span>    ++<span class="comment">(a</span>++<span class="comment">);</span>  <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">a</span>++ <span class="comment">=</span> <span class="comment">1;</span>   <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">(</span>++<span class="comment">a)</span>++<span class="comment">;</span>  <span class="comment">//OK</span></span><br><span class="line"><span class="comment"></span>    ++<span class="comment">(</span>++<span class="comment">a);</span>  <span class="comment">//OK</span></span><br><span class="line"><span class="comment"></span>    ++<span class="comment">a</span> <span class="comment">=</span> <span class="comment">1;</span>   <span class="comment">//OK</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<p>++的类型是const Age，自然不能对它进行前置++、后置++、赋值等操作。</p>
<p>++a的类型是Age&amp;，当然可以对它进行前置++、后置++、赋值等操作</p>
<p><strong>a++的返回类型为什么要是const对象呢？</strong></p>
<p>对于内置类型，(i++)++这样的表达式是不能通过编译的。自定义类型的操作符重载，应该与内置类型保持行为一致</p>
<p><strong>2. 形参不同</strong></p>
<p>前置++没有形参，而后置++有一个int形参</p>
<p><strong>3.代码实现的区别</strong></p>
<p>前置++的实现比较简单，自增之后，将<em>this返回即可。需要注意的是，一定要返回</em>this。</p>
<p>后置++的实现稍微麻烦一些。因为要返回自增之前的对象，所以先将对象拷贝一份，再进行自增，最后返回那个拷贝</p>
<p><strong>4.效率的区别</strong></p>
<p>前置++的效率更高，理由是：后置++会生成临时对象</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>指针、数组和函数</title>
    <url>/2020/02/11/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>数组指针和指针数组</strong></p>
<p><strong>数组指针</strong></p>
<p>定义 int (*p)[n];</p>
<p>()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度</p>
<p>如要将二维数组赋给一指针，应这样赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>]; <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组。</span></span><br><span class="line">p=a;        <span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span></span><br><span class="line">p++;       <span class="comment">//该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span></span><br></pre></td></tr></table></figure>

<p><strong>指针数组</strong></p>
<p>定义 int *p[n];</p>
<p>[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值</p>
<p>如要将二维数组赋给一指针数组:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	p[i]=a[i];</span><br></pre></td></tr></table></figure>

<p>这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]，所以要分别赋值</p>
<p><strong>指针数组和数组指针的内存布局</strong></p>
<img src="/2020/02/11/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/22201218-19ddd896ae6a45e1b61c7e3ee59b4662.jpg" alt="img" style="zoom: 80%;">

<hr>
<p><strong>函数指针和指针函数</strong></p>
<p><strong>指针函数</strong></p>
<p>指针函数，简单的来说，就是一个<strong>返回指针</strong>的函数，其本质是一个函数，而该函数的返回值是一个指针。<br>声明格式为：<strong>类型标识符 *函数名(参数表)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        sum = a + b;</span><br><span class="line">        <span class="keyword">return</span> &amp;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">        p=add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add result is %d\n"</span>, *p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数指针</strong></p>
<p>函数指针，其本质是一个<strong>指针变量</strong>，该<strong>指针指向这个函数</strong>。总结来说，函数指针就是指向函数的指针。<br>声明格式：类型说明符  (*函数名)  (参数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br></pre></td></tr></table></figure>

<p>函数指针是需要把一个函数的地址赋值给它，有两种写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure>

<p>调用函数指针的方式也有两种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        p=add;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add result is %d\n"</span>, p(<span class="number">200</span>,<span class="number">300</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>一种string类的简单实现</title>
    <url>/2020/01/20/%E4%B8%80%E7%A7%8Dstring%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>C++中String类的简单实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    myString(<span class="keyword">const</span> <span class="keyword">char</span> *str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *data = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    myString(<span class="keyword">const</span> myString &amp;str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    myString(myString&amp;&amp; str):data(str.data)&#123;</span><br><span class="line">        str.data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">    myString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> myString &amp;str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">    myString&amp; <span class="keyword">operator</span>=(myString&amp;&amp; str)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = str.data;</span><br><span class="line">        str.data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~myString()&#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">String</span> s0; <span class="comment">//构造</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>; <span class="comment">//构造</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">s2</span><span class="params">(s0)</span></span>;</span><br><span class="line">    <span class="keyword">String</span> s3 = s1;</span><br><span class="line">    s2 = s1;</span><br><span class="line"></span><br><span class="line">    foo(s1);</span><br><span class="line">    bar(s1);</span><br><span class="line">    foo(<span class="string">"temporary"</span>);</span><br><span class="line">    bar(<span class="string">"temporary"</span>);</span><br><span class="line">    <span class="keyword">String</span> s4 = baz();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">String</span>&gt; svec;</span><br><span class="line">    svec.push_back(s0);</span><br><span class="line">    svec.push_back(s1);</span><br><span class="line">    svec.push_back(baz());</span><br><span class="line">    svec.push_back(<span class="string">"good job"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝赋值</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">移动构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">移动构造</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确地删除vector中符合条件的某元素</title>
    <url>/2019/11/20/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%88%A0%E9%99%A4vector%E4%B8%AD%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9F%90%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>比如，有一个vector&lt; int &gt; nums = {1, 2, 2, 2, 2, 3, 5}，要求删除nums中所有值为2的元素 </p>
<h3 id="一个符合直觉的错误实现"><a href="#一个符合直觉的错误实现" class="headerlink" title="一个符合直觉的错误实现"></a>一个符合直觉的错误实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123; </span><br><span class="line">        nums.erase(it); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码循环遍历nums中的每个元素，判断是否为2，是的话则erase掉。看起来好像没什么问题，但是实际上已经造成了bug。这段代码的执行完成后，<strong>nums存储的元素是{1, 2, 2, 3, 5}</strong>，值为2的元素并没有被全部清除掉。</p>
<p>为什么会出现这个结果呢？原因就是<strong>迭代器失效</strong> ：在第一个2被erase掉的时候，it迭代器已经失效了，它指向了被删除元素的下一个元素，用它来继续遍历vector就会漏掉被删除元素后面的第一个元素，导致2没有被完全清除。</p>
<h3 id="第一种正确实现：让it指向下一个元素"><a href="#第一种正确实现：让it指向下一个元素" class="headerlink" title="第一种正确实现：让it指向下一个元素"></a>第一种正确实现：让it指向下一个元素</h3><p><strong>erase函数的返回值是指向当前被删除元素的下一个元素的迭代器</strong>。那么我们把这个返回值赋值给it继续遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">        it = nums.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种正确实现：erase-remove"><a href="#第二种正确实现：erase-remove" class="headerlink" title="第二种正确实现：erase-remove"></a>第二种正确实现：erase-remove</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    nums.erase(<span class="built_in">remove</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(), <span class="number">2</span>), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>erase</strong>用来删除一段区间的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>remove</strong>  <strong>移除但不删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它<strong>并不真正从容器中删除那些元素</strong>（换句话说容器的大小不变），<strong>而是将每一个不与value相等（也就是我们不打算移除）的元素轮番赋值给first之后的空间</strong>。</p>
<p>例如：{0，1，0，2，0，3，0，4}，用remove移除值为0的元素，执行结果为{1，2，3，4，0，3，0，4}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>) &#123;</span></span><br><span class="line">    first = <span class="built_in">find</span>(first, last, value);</span><br><span class="line">    ForwardIterator next = first;</span><br><span class="line">    <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> remove_copy(++next, last, first, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove_copy</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">IntputIt</span> <span class="title">first</span>,<span class="title">IntputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它并不真正从容器中删除那些元素（换句话说容器的大小不变）,而是<strong>将结果复制到一个以result标示起始位置的容器上，新容器可以和原容器重叠。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">OutputIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIt</span> <span class="title">remove_copy</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first!=last;++first)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*first!=value)&#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









































]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C库函数memcpy()和memmove()的区别</title>
    <url>/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>memcpy( )和memmove( )都是C语言中的库函数，在头文件string.h中。</p>
<p>其作用是从src内存中拷贝n个字节到dest内存区域中，原型分别如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="memcpy-和memmove-的区别"><a href="#memcpy-和memmove-的区别" class="headerlink" title="memcpy()和memmove()的区别"></a>memcpy()和memmove()的区别</h3><p>他们的作用是一样的，<strong>唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。</strong></p>
<p><img src="/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/memory.png" alt="memory"></p>
<h3 id="memcpy-函数的实现"><a href="#memcpy-函数的实现" class="headerlink" title="memcpy()函数的实现"></a>memcpy()函数的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    <span class="keyword">char</span> *s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        *tmp++ = *s_src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="memmove-实现函数"><a href="#memmove-实现函数" class="headerlink" title="memmove()实现函数"></a>memmove()实现函数</h3><p>memmove就是针对第二种内存覆盖情形，对memcpy进行了改进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memmove</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s_dst;</span><br><span class="line">    <span class="keyword">char</span>* s_src;</span><br><span class="line">    s_dst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">if</span>(s_dst&gt;s_src &amp;&amp; (s_src+n&gt;s_dst)) &#123;      <span class="comment">//第二种内存覆盖的情形。</span></span><br><span class="line">        <span class="comment">// 从后往前复制，防止出现内存覆盖的情形</span></span><br><span class="line">        s_dst = s_dst+n<span class="number">-1</span>;</span><br><span class="line">        s_src = s_src+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst-- = *s_src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst++ = *s_src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
