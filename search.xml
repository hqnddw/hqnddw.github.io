<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>链表之快慢指针</title>
    <url>/2020/10/05/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>链表的快慢指针指声明两个指针slow和fast，slow每次走一步，fast每次走两步</p>
<p>几种应用到快慢指针的场景：</p>
<p><strong>寻找链表的中点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode *p1 = head, *p2 = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p2 &amp;&amp; p2-&gt;next) &#123;</span><br><span class="line">      p1 = p1-&gt;next;</span><br><span class="line">      p2 = p2-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p1即为链表的中点</span></span><br></pre></td></tr></table></figure>

<p><strong>检测链表中是否有环</strong></p>
<p>用两个指针slow和fast，初始化指向链表头部，slow走一步，fast走两步，如果两个指针能够相遇，说明链表中有环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="comment">//检测fast-&gt;next是否为null，是因为当fast-&gt;next为null时，fast-&gt;next-&gt;next不存在</span></span><br><span class="line">        <span class="keyword">while</span>(fast  &amp;&amp; fast -&gt; next)&#123;</span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>检测链表中是否有环并找到环开始的节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123; <span class="comment">// 此时快慢指针相遇，证明链表有环</span></span><br><span class="line">                <span class="comment">// 慢指针从链表头部开始遍历</span></span><br><span class="line">                ListNode *slow2 = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != slow2) &#123; <span class="comment">// 在环开始的点相遇</span></span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    slow2 = slow2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2020/10/05/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/微信图片_20190829113352.jpg" alt="微信图片_20190829113352" style="zoom:50%;">

<p><strong>找到两个链表的相交节点</strong></p>
<p>两种方法：</p>
<ul>
<li>A, B两个链表，假设长度A&gt;B，A，B两个头节点一步步遍历，当B到达尾节点时，将B指向A的头节点，当A到达尾节点时，将A指向B的头节点，继续遍历，当两个节点相等时，即到达相交节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *ptrA = headA, *ptrB = headB;</span><br><span class="line">    <span class="keyword">while</span> (ptrA != ptrB) &#123;</span><br><span class="line">        ptrA = ptrA ? ptrA-&gt;next : headB;</span><br><span class="line">        ptrB = ptrB ? ptrB-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptrA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>将A， B两个链表连接，即A+B， B+A， 从头开始分别遍历，当相等时，即到达相交节点</li>
</ul>
<p><strong>寻找重复数</strong></p>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<img src="/2020/10/05/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/image-20201005200439527.png" alt="image-20201005200439527" style="zoom:67%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis对象</title>
    <url>/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Redis并没有直接SDS、双端链表、字典、压缩列表、整数集合等数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们之前介绍的数据结构</p>
<p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。<strong>使用对象的另一个好处是，我们可以根据不同的使用场景，为对象设置多种不同的数据结构实现</strong>，从而优化对象在不同场景下的使用效率</p>
<p>Redis共有五种对象的类型，分别是：</p>
<table>
<thead>
<tr>
<th align="center">对象</th>
<th align="center">对象type属性的值</th>
<th align="center">TYPE命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符串对象</td>
<td align="center">REDIS_STRING</td>
<td align="center">string</td>
</tr>
<tr>
<td align="center">列表对象</td>
<td align="center">REDIS_LIST</td>
<td align="center">list</td>
</tr>
<tr>
<td align="center">哈希对象</td>
<td align="center">REDIS_HASH</td>
<td align="center">hash</td>
</tr>
<tr>
<td align="center">集合对象</td>
<td align="center">REDIS_SET</td>
<td align="center">set</td>
</tr>
<tr>
<td align="center">有序集合对象</td>
<td align="center">REDIS_ZSET</td>
<td align="center">zset</td>
</tr>
</tbody></table>
<p>Redis中的一个对象的结构体表示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;        </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 不使用(对齐位)</span></span><br><span class="line">    <span class="keyword">unsigned</span> notused:<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// LRU 时间（相对于 server.lruclock）</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向对象的值</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"> </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><strong>访问时间lru</strong></p>
<p>lru表示该对象最后一次被访问的时间，其占用22个bit位。保存该值的目的是为了计算该对象的空转时长，便于后续根据空转时长来决定是否释放该键，回收内存。</p>
<p><strong>引用计数refcount</strong></p>
<p>C语言不具备自动内存回收机制，所以Redis对每一个对象设定了引用计数refcount字段，程序通过该字段的信息，在适当的时候自动释放内存进行内存回收。此功能与C++的智能指针相似。</p>
<ul>
<li>当创建一个对象时，其引用计数初始化为1；</li>
<li>当这个对象被一个新程序使用时，其引用计数加1；</li>
<li>当这个对象不再被一个程序使用时，其引用计数减1；</li>
<li>当引用计数为0时，释放该对象，回收内存。</li>
</ul>
<p><strong>编码和底层实现</strong></p>
<p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。encoding属性记录了对象使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是下表列出的常量的其中一个</p>
<table>
<thead>
<tr>
<th align="center">编码常量</th>
<th align="center">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody><tr>
<td align="center">REDIS_ENCODING_INT</td>
<td align="center">long类型的整数</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_EMBSTR</td>
<td align="center">embstr编码的简单动态字符串</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_RAW</td>
<td align="center">简单动态字符串</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_HT</td>
<td align="center">字典</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_LINKEDLIST</td>
<td align="center">双端链表</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">压缩列表</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_INTSET</td>
<td align="center">整数集合</td>
</tr>
<tr>
<td align="center">REDIS_ENCODING_SKIPLIST</td>
<td align="center">跳跃表和字典</td>
</tr>
</tbody></table>
<p>每种类型的对象都至少使用了两种不同的编码，下表列出了每种类型的对象可以使用的编码</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">编码</th>
<th align="center">对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">REDIS_STRING</td>
<td align="center">REDIS_ENCODING_INT</td>
<td align="center">使用整数值实现的字符串对象</td>
</tr>
<tr>
<td align="center">REDIS_STRING</td>
<td align="center">REDIS_ENCODING_EMBSTR</td>
<td align="center">使用embstr编码的简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td align="center">REDIS_STRING</td>
<td align="center">REDIS_ENCODING_RAW</td>
<td align="center">使用简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td align="center">REDIS_LIST</td>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">使用压缩列表实现的列表对象</td>
</tr>
<tr>
<td align="center">REDIS_LIST</td>
<td align="center">REDIS_ENCODING_LINKEDLIST</td>
<td align="center">使用双端链表实现的列表对象</td>
</tr>
<tr>
<td align="center">REDIS_HASH</td>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">使用压缩列表实现的哈希对象</td>
</tr>
<tr>
<td align="center">REDIS_HASH</td>
<td align="center">REDIS_ENCODING_HT</td>
<td align="center">使用字典实现的哈希对象</td>
</tr>
<tr>
<td align="center">REDIS_SET</td>
<td align="center">REDIS_ENCODING_INTSET</td>
<td align="center">使用整数集合实现的集合对象</td>
</tr>
<tr>
<td align="center">REDIS_SET</td>
<td align="center">REDIS_ENCODING_HT</td>
<td align="center">使用字典实现的集合对象</td>
</tr>
<tr>
<td align="center">REDIS_ZSET</td>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">使用压缩列表实现的有序集合对象</td>
</tr>
<tr>
<td align="center">REDIS_ZSET</td>
<td align="center">REDIS_ENCODING_SKIPLIST</td>
<td align="center">使用跳跃表和字典实现的有序集合对象</td>
</tr>
</tbody></table>
<p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET msg "hello wrold"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING msg</span><br><span class="line">"embstr"</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是int、raw或者embstr。</p>
<p>如果一个字符串的内容可以转换为long，那么该字符串就会被转换成为long类型，对象的ptr就会指向该long，并且对象类型也用int类型表示</p>
<p>普通的字符串有两种，embstr和raw。embstr应该是Redis 3.0新增的数据结构,在2.8中是没有的。如果字符串对象的长度小于39字节，就用embstr对象。否则用传统的raw对象。可以从下面这段代码看出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>embstr的好处</strong>有如下几点：</p>
<ul>
<li>embstr的创建只需分配一次内存，而raw为两次（一次为sds分配对象，另一次为objet分配对象，embstr省去了第一次）</li>
<li>相对地，释放内存的次数也由两次变为一次</li>
<li>embstr的objet和sds放在一起，更好地利用缓存带来的优势</li>
</ul>
<p>raw和embstr的区别可以用下面两幅图所示：</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005184457915.png" alt="image-20201005184457915" style="zoom: 67%;">

<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005184512867.png" alt="image-20201005184512867" style="zoom:67%;">

<p>字符串对象保存各类型值的编码方式</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">编码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可以用long类型保存的整数</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">可以用long double类型保存的浮点数</td>
<td align="center">embstr或者raw</td>
</tr>
<tr>
<td align="center">字符串值，或者因为长度太大而没办法用long类型表示的整数，又或者因为长度太大而没办法用long double类型表示的浮点数</td>
<td align="center">embstr或者raw</td>
</tr>
</tbody></table>
<p><strong>编码转换</strong></p>
<ul>
<li>对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得对象保存的不再是整数值，而是一个字符串值，那么字符串对象将从int变为raw</li>
<li>redis并未提供任何修改embstr的方式，即embstr是只读的形式。对embstr的修改实际上是先转换为raw再进行修改</li>
</ul>
<hr>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以是ziplist或者linkedlist。</p>
<p><code>ziplist</code>是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用ziplist存储</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005185321906.png" alt="image-20201005185321906" style="zoom:67%;">

<p><code>linkedlist</code> 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素    </p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005185429927.png" alt="image-20201005185429927" style="zoom:67%;">

<p><strong>编码转换：</strong></p>
<p>当列表对象可以同时满足以下两个条件时， 列表对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li>
<li>列表对象保存的元素数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的列表对象需要使用 <code>linkedlist</code> 编码</p>
<hr>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。</p>
<p><code>ziplist</code> 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向</li>
</ul>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005185847324.png" alt="image-20201005185847324" style="zoom:67%;">

<p><code>hashtable</code> 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值</li>
</ul>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005185935575.png" alt="image-20201005185935575" style="zoom:67%;">

<p><strong>编码转换</strong></p>
<p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li>
<li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的哈希对象需要使用 <code>hashtable</code> 编码</p>
<hr>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是 intset 或者 hashtable 。</p>
<p>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005190917671.png" alt="image-20201005190917671" style="zoom:67%;">

<p>hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005191004670.png" alt="image-20201005191004670" style="zoom:67%;">

<p><strong>编码的转换</strong></p>
<p>当集合对象可以同时满足以下两个条件时， 对象使用 <code>intset</code> 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p>
<hr>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> 。</p>
<p><code>ziplist</code> 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005191802735.png" alt="image-20201005191802735" style="zoom:67%;">

<p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p><code>zset</code> 结构中的 <code>zsl</code> 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 <code>object</code> 属性保存了元素的成员， 而跳跃表节点的 <code>score</code> 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外， <code>zset</code> 结构中的 <code>dict</code> 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性</p>
<img src="/2020/10/05/Redis%E5%AF%B9%E8%B1%A1/image-20201005192352716.png" alt="image-20201005192352716" style="zoom:67%;">

<p><strong>编码的转换</strong></p>
<p>当有序集合对象可以同时满足以下两个条件时， 对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ol>
<p>不能满足以上两个条件的有序集合对象将使用 <code>skiplist</code> 编码。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之压缩列表</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>压缩列表是列表键和哈希键的底层实现之一。</p>
<p>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，redis就会使用压缩列表来做列表键的底层实现</p>
<p>当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</p>
<h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>压缩列表是Redis为了节约内存而开发的是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/Redis压缩列表结构.png" alt="img" style="zoom:67%;">

<p>示例：</p>
<p><img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84-Example.png" alt="img"></p>
<p>  如上图，展示了一个总长为80字节，包含3个节点的压缩列表。如果我们有一个指向压缩列表起始地址的指针p，那么表为节点的地址就是P+60</p>
<h3 id="Redis压缩列表节点的构成"><a href="#Redis压缩列表节点的构成" class="headerlink" title="Redis压缩列表节点的构成"></a>Redis压缩列表节点的构成</h3><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。</p>
<p>其中，字节数组可以是以下三种长度中的一种</p>
<ul>
<li>长度小于等于63(2^6-1)字节的字节数组;</li>
<li>长度小于等于16383(2^14-1)字节的字节数组</li>
<li>长度小于等于4294967295(2^32-1)字节的字节数组</li>
</ul>
<p>整数值可以是以下6种长度中的一种</p>
<ul>
<li>4位长,介于0至12之间的无符号整数</li>
<li>1字节长的有符号整数</li>
<li>3字节长的有符号整数</li>
<li>int16_t类型整数</li>
<li>int32_t类型整数</li>
<li>int64_t类型整数</li>
</ul>
<p>每个压缩列表节点都由 <code>previous_entry_length</code> 、 <code>encoding</code> 、 <code>content</code> 三个部分组成</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/压缩列表节点.png" alt="img" style="zoom:67%;">

<p> <strong>previous_entry_length</strong></p>
<p>节点的 previous_entry_length属性以字节为单位,记录了压缩列表中前一个节点的长度。 previous_entry_length属性的长度可以是1字节或者5字节</p>
<ul>
<li>如果前一节点的长度小于254字节，那么 previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于254字节,那么 previous_entry_length属性的长度为5字节:其中属性的第一字节会被设置为0xFE(十进制值254),而之后的四个字节则用于保存前一节点的长度</li>
</ul>
<p>因为节点的 <code>previous_entry_length</code> 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p>
<p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 <code>previous_entry_length</code> 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点</p>
<p><strong>encoding</strong></p>
<p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度</p>
<ul>
<li>一字节、两字节或者五字节长,值的最高位为00、01或者10的是字节数组编码这种编码表示节点的 content属性保存着字节数组,数组的长度由编码除去最高两位之后的其他位记录。</li>
<li>一字节长,值的最高位以11开头的是整数编码:这种编码表示节点的content属性保存着整数值,整数值的类型和长度由编码除去最高两位之后的其他位记录。</li>
</ul>
<p><strong>content</strong></p>
<p>节点的content属性负责保存节点的值,节点值可以是一个字节数组或者整数,值的类型和长度由节点的encoding属性决定</p>
<p><img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B1.png" alt="img"></p>
<hr>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>每个节点的<code>previous_entry_length</code>都记录了前一个节点的长度,如果长度小于254那么<code>previous_entry_length</code>需要用1字节来保存这个长度值。现在假设这种情况:压缩列表有多个连续的长度介于<code>250-253</code>之间的节点e1-eN。因为每个节点的长度都小于254字节，所以这些节点的<code>previous_entry_length</code>属性都是1字节长度</p>
<p>此时如果将一个长度大于254的新节点设置为压缩列表的头节点，那么这个新节点成为头节点，也就是e1节点的前置节点。此时将e1的<code>previous_entry_length</code>扩展为5字节长度,此时e1又超过了254，于是e2的<code>previous_entry_length</code>也超过了254··· .此时这些节点就会连锁式的更新，并重新分配空间</p>
<p>作者：都是浮云啊<br>链接：<a href="https://www.jianshu.com/p/6292459aff23" target="_blank" rel="noopener">https://www.jianshu.com/p/6292459aff23</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之整数集合</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis i就会使用整数集合作为集合键的底层实现</p>
<h3 id="整数集合实现"><a href="#整数集合实现" class="headerlink" title="整数集合实现"></a>整数集合实现</h3><p>整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个intset结构表示一个整数集合</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合中包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<ul>
<li>contents数组是整数集合的底层实现，整数集合的每个元素都是contents数组的个数组项(item)，各个项在数组中按值的大小<strong>从小到大有序地排列</strong>，并且数组中<strong>不包含任何重复项</strong>。</li>
<li>length属性记录了数组的长度</li>
<li>intset结构将contents属性声明为int8_t类型的数组,但实际上 contents数组并不保存任何int8_t类型的值, contents数组的真正类型取决于encoding属性的值</li>
</ul>
<p>一个整数集合实例：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/747151-20180603165111987-424577529.png" alt="img">

<hr>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面</p>
<p><strong>升级并添加新元素过程：</strong></p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间 </li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变</li>
<li>将新元素添加到底层数组里面</li>
</ol>
<blockquote>
<p>升级后新元素的摆放位置</p>
<p>因为引发升级的新元素的长度总是比整数集合现在所有的元素长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素，即新元素的位置要么在数组最开头，要么被放在数组最末尾</p>
</blockquote>
<p><strong>升级的好处：</strong></p>
<ol>
<li>提升灵活性：可随意将整数添加到整数集合中而不必考虑其类型，不会发生类型错误</li>
<li>节约内存：总是使用能容纳集合所有元素的最小类型，只有在需要的时候才会进行升级</li>
</ol>
<p><strong>升级的局限：</strong></p>
<ul>
<li>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态</li>
</ul>
<p>因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之跳跃表</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</p>
<p>跳跃表支持平均 O(log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点</p>
<p>Redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的<strong>元素数量比较多</strong>,又或者有序集合中元素的<strong>成员是比较长的字符串</strong>时, Redis就会使用跳跃表来作为有序集合健的底层实现</p>
<p>Redis 只在两个地方用到了跳跃表， 一个是实现有序集合键， 另一个是在集群节点中用作内部数据结构</p>
<hr>
<h3 id="Redis中跳跃表的实现"><a href="#Redis中跳跃表的实现" class="headerlink" title="Redis中跳跃表的实现"></a>Redis中跳跃表的实现</h3><p>Redis的跳跃表由<strong>zskiplistNode</strong>和<strong>skiplist</strong>两个结构定义,其中 zskiplistNode结构用于表示跳跃表节点,而 zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/Redis跳跃表.png" alt="Redis跳跃表" style="zoom: 67%;">

<p>上图展示了一个跳跃表示例,其中最左边的是 skiplist结构,该结构包含以下属性：</p>
<ul>
<li>header：指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)</li>
<li>tail：指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)</li>
<li>level：记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最高的节点的层数</li>
<li>length：记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<hr>
<p>结构右方的是四个 zskiplistNode结构,该结构包含以下属性：</p>
<ul>
<li><p>层(level)：节点中用1、2、L3等字样标记节点的各个层,L1代表第一层,L代表第二层,以此类推。每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的高度。</p>
<p>每个层都带有两个属性:<strong>前进指针</strong>和<strong>跨度</strong>。</p>
<ul>
<li>前进指针用于访问位于表尾方向的其他节点</li>
<li>跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)</li>
</ul>
</li>
<li><p>后退(backward)指针：节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点</p>
</li>
<li><p>分值(score)：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列</p>
</li>
<li><p>成员对象(oj)：各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span> </span><br><span class="line">    <span class="comment">//member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">   <span class="comment">// 分值</span></span><br><span class="line">   <span class="keyword">double</span> score;</span><br><span class="line">  <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  <span class="comment">// 层 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">   <span class="comment">// 前进指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">  <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> span; </span><br><span class="line">  &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之字典</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<p>字典是一种用于保存键值对（key-value pair）的抽象数据结构，在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。</p>
<p>字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。</p>
<hr>
<h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p><strong>Redis的字典使用哈希表作为底层实现</strong>，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对</p>
<p>Redis字典所使用的哈希表结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>table属性是一个<strong>数组</strong>，数组中的每个元素都指向一个dictEntry结构的指针，每个dictEntry结构保存着一个键值对。</p>
<p>size属性记录了哈希表的大小，即table数组的大小，而used属性则记录了哈希表目前已有键值对的数量。</p>
<p>sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上</p>
<p>下图展示了一个大小为4的空哈希表：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/image-20201002173245108.png" alt="image-20201002173245108" style="zoom:80%;">

<h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存一个键值对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>key属性保持着键值对中的键，而v属性则保存着键值对中的值，其中键值对中的值可以是一个指针，或者是一个整数。</p>
<p>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，来解决<strong>键冲突问题</strong>（以链表的方式解决冲突问题）。</p>
<p>如下图表示一个完成的哈希表：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/image-20201002173545433.png" alt="image-20201002173545433" style="zoom:80%;">

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>type属性和privdata属性是针对不同类型的键值对，而创建多态字典而设置的</p>
<ul>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一组用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同类型的特定函数</li>
<li>privadata属性则保存了需要传给那些类型特定函数的可选参数</li>
</ul>
<p><strong>ht属性是一个包含了两个项的数组，数组中每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，而ht[1]哈希表只对ht[0]哈希表进行<code>rehash</code>时使用</strong></p>
<p>另一个与rehash有关的就是rehashidx属性，它积累了rehash目前的进度，如果没有进行rehash，则它的值为-1</p>
<p>下图为一个普通状态下的字典结构：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8/image-20201002173956795.png" alt="image-20201002173956795" style="zoom: 75%;">

<hr>
<h3 id="哈希算法和哈希冲突"><a href="#哈希算法和哈希冲突" class="headerlink" title="哈希算法和哈希冲突"></a>哈希算法和哈希冲突</h3><p>将一个新的键值对添加到字典里面的时候，程序需要先根据键值对上面的键来计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希数组的指定索引上面。</p>
<p>Redis计算哈希值和索引值的方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment">// 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p><em>Redis使用MurmurHash2算法来计算键的哈希值</em></p>
<p>Redis哈希表使用<strong>链地址法</strong>来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next构成一个单向链表，被分配到同一个索引上的节点可以用这个单向链表连接起来，从而解决键冲突问题</p>
<p>因为dictEntry节点组成的链表没有指向链表表尾的指针，为了考虑速度，<strong>程序总是将新节点添加到链表的表头位置（这样添加节点的时间复杂度为O(1)</strong></p>
<hr>
<h3 id="rehash和渐进式rehash"><a href="#rehash和渐进式rehash" class="headerlink" title="rehash和渐进式rehash"></a>rehash和渐进式rehash</h3><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a><strong>rehash</strong></h4><p>随着操作的不断进行，哈希表保存的键值对会逐渐增多或减少，为了让哈希表<strong>负载因子</strong>维持在一个合理范围之内，当哈希表保存的键值对太多或太少时，程序要对哈希表的大小进行相应的扩展或收缩。</p>
<p>Redis对字典的哈希表执行rehash的步骤如下：</p>
<ol>
<li>为字典的ht[1]哈希表分配空间，这个空间大小取决于要执行的操作<ul>
<li>如果执行的是扩展操作，则ht[1]的大小为第一个大于等于等于ht[0].used*2的2^n</li>
<li>如果执行的收缩操作，则ht[1]的大小为第一个大于等于ht[0].used的2^n</li>
</ul>
</li>
<li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]的指定位置上</li>
<li>当ht[0]包含的所有键值对都迁移到ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备</li>
</ol>
<p><strong>哈希表的扩展与收缩</strong></p>
<p>当以下条件中任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p>
<ul>
<li>服务器目前没有执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子大于等于1</li>
<li>服务器正在执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子大于等于5</li>
</ul>
<p>另一方面，当哈希表负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>Redis中的rehash动作并不是一次性、集中式完成的，而是<strong>分多次、渐进式的完成的。</strong></p>
<p>这样做的目的是，如果服务器中包含很多键值对，要一次性的将这些键值对全部rehash到ht[1]的话，庞大的计算量可能导致服务器在一段时间内停止服务于。</p>
<p>为了避免这种影响，Redis采用了<strong>渐进式Redis</strong>：</p>
<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它置为0，表示rehash工作开始</li>
<li>在rehash进行期间，<strong>每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]中</strong>，当rehash工作完成之后，程序将rehashidx属性的值+1</li>
<li>随着字典操作的不断进行，最终在某个时间点上，ht[0]的所有键值对都被rehash到ht[1]上，这时将rehashidx属性设为-1，表示rehash完成</li>
</ol>
<p><strong>渐进式rehash</strong>的好处在于其采取<strong>分而治之</strong>的方式，将rehash键值对所需要的计算工作均摊到字典的<strong>每个</strong>添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量</p>
<p><strong>渐进式rehash执行期间的哈希表操作</strong></p>
<p>因为在渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找、更新等操作都是在两个表上进行的。</p>
<p>例如，<strong>查找</strong>操作会先在ht[0]上进行，如果没找到再在ht[1]上进行。<strong>添加</strong>操作的键值对会一律保存到ht[1]中，这一措施保证ht[0]包含的键值对只会减少不会增加。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之链表</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表在 Redis 中的应用非常广泛， 比如列表键的底层实现之一就是链表： 当一个列表键包含了数量比较多的元素， 又或者列表中包含的元素都是比较长的字符串时， Redis 就会使用链表作为列表键的底层实现。</p>
<p>除了链表键之外， 发布与订阅、慢查询、监视器等功能也用到了链表， Redis 服务器本身还使用链表来保存多个客户端的状态信息， 以及使用链表来构建客户端输出缓冲区（output buffer）</p>
<p>Redis链表为双向无环链表</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/image-20201002171439480.png" alt="image-20201002171439480" style="zoom: 80%;">

<p>如图所示，Redis使用一个listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="comment">// 前置节点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span> </span><br><span class="line">	<span class="comment">// 后置节点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> </span><br><span class="line">	<span class="comment">// 节点的值 </span></span><br><span class="line">	<span class="keyword">void</span> *value; </span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>同时Redis为了方便的操作链表，提供了一个<strong>list结构</strong>来持有链表。如下图所示</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/image-20201002171607721.png" alt="image-20201002171607721" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Redis链表结构其主要特性如下:</strong></p>
<ul>
<li>双向：链表节点带有prev和next指针，获取某个节点的前驱、后继节点的时间复杂度为0(1)</li>
<li>无环: 链表为非循环链表，表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</li>
<li>带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1)</li>
<li>带链表长度计数器：通过list结构的len属性获取节点数量的时间复杂度为O(1)</li>
<li>多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构之SDS</title>
    <url>/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</url>
    <content><![CDATA[<p> 字符串在Redis中使用非常广泛，在Redis中，所有的数据都保存在字典（Map）中，而字典的键就是字符串类型，并且对于很大一部分字典值数据也是又字符串组成的。以下是SDS的具体存储结构：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/202205_cXnQ_2831721.png" alt="img" style="zoom:80%;">

<p>从图中可以看出，SDS的属性有三个：len、free和buf数组：</p>
<ul>
<li>len字段是用来保存SDS字符串中所包含字符数目的</li>
<li>free字段则是用来保存buf数组中空余的部分的长度的</li>
<li>buf数组则是实际用来保存字符串的</li>
</ul>
<p>比如如下结构保存了“Hello World！”这个字符串：</p>
<img src="/2020/09/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/204859_FBGP_2831721.png" alt="img" style="zoom:80%;">

<p>这里需要注意的是，SDS和C字符串一样，需要在字符串结尾加上一个’\0’表示该字符串的结束（可以直接使用C字符串库里面的函数）</p>
<p><strong>Redis使用SDS结构而不用c字符串保存字符串的原因有如下几点</strong>：</p>
<ol>
<li><strong>常数复杂度获取字符串长度</strong><ul>
<li>通过读取SDS对象的len属性的值我们可以使用O(1)获取SDS对象保存的字符串长度</li>
<li>在c字符串中，我们必须对整个数组进行遍历从而获取字符串的长度，其时间复杂度为O(N)</li>
</ul>
</li>
<li><strong>杜绝缓冲区溢出</strong><ul>
<li>在C字符串中，比如char *strcat(char *dest, const char *src)函数将src连接到dest的末尾，但是c字符串假定dest数组中有足够的空余空间来保存src数组，如果dest数组长度不够就会造成缓冲区溢出</li>
<li>在SDS对象中也提供了类似的函数SDS SDScat(SDS s, const char *t)和SDS SDScatSDS(SDS s, const SDS t)，这两个函数在调用之前会检查目标SDS对象s中free属性是否能够保存要连接的字符串的长度，如果不够，就会对目标SDS对象扩容，这就保证了SDS对象不会造成缓冲区溢出</li>
</ul>
</li>
<li><strong>减少修改字符串时内存重分配的次数</strong><ul>
<li>对于c字符串，每次对其进行修改都需要进行一次空间分配和复制操作，否则会造成缓冲区溢出和内存泄漏</li>
<li>在对SDS进行修改的时候，Redis可以通过<strong>空间预分配</strong>和<strong>惰性空间释放</strong>来保证后续对SDS对象的频繁修改而不会造成SDS对象的buf数组经常分配空间<ol>
<li>空间预分配：对于追加操作来说，Redis不仅会开辟空间至够用而且还会预分配未使用的空间(free)来用于下一次操作。至于未使用的空间(free)的大小则由修改后的字符串长度决定<ul>
<li>当修改后的字符串长度len &lt; 1M,则会分配与len相同长度的未使用的空间</li>
<li>当修改后的字符串长度len &gt;= 1M,则会分配1M长度的未使用的空间</li>
</ul>
</li>
<li>惰性空间回收：在对SDS的字符串进行缩短操作的时候，程序并不会立刻使用内存重分配来回收缩短之后多出来的字节，而是使用free属性将这些字节的数量记录下来等待将来使用</li>
</ol>
</li>
</ul>
</li>
<li><strong>二进制安全</strong><ul>
<li>对于c字符串，由于其判断是否结束的标志是从字符串开始到结尾碰到的第一个“\0”字符，这就限制了c字符串不能保存像图片、音频、视频、压缩文件等二进制保存的内容</li>
<li>对于SDS对象，由于判断其是否结束的标志是其len属性，也就是说无论在len长度内，buf数组中是否包含“\0”都不影响Redis判断其是否结束</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th align="center">C字符串</th>
<th align="center">SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">获取字符串长度的复杂度为O(N)</td>
<td align="center">获取字符串长度的复杂度为O(1)</td>
</tr>
<tr>
<td align="center">API是不安全的，可能会造成缓冲区溢出</td>
<td align="center">API是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td align="center">修改字符串长度N次必然需要执行N次内存分配操作</td>
<td align="center">修改字符串长度N次最多需要执行N次内存分配操作</td>
</tr>
<tr>
<td align="center">只能保存文本数据</td>
<td align="center">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td align="center">可以使用所有&lt;string.h&gt;库中的函数</td>
<td align="center">可以使用一部分&lt;string.h&gt;库中的函数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库缓冲池</title>
    <url>/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/</url>
    <content><![CDATA[<p>应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在<strong>缓存</strong>(cache)里，避免每次都去访问数据库。操作系统会有<strong>缓冲池</strong>(buffer pool)机制，避免每次都访问磁盘，以加速数据的访问。MySQL作为一个存储系统，同样具有<strong>缓冲池</strong>(buffer pool)机制，以避免每次查询数据都进行磁盘IO</p>
<p><strong>InnoDB的缓冲池缓存什么？有什么用？</strong></p>
<p>缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用。</p>
<p><strong>如何管理与淘汰缓冲池，使得性能最大化呢？</strong></p>
<p>在介绍具体细节之前，先介绍下“预读”的概念。</p>
<p><strong>什么是预读？</strong>磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。 </p>
<p><strong>预读为什么有效？</strong>数据访问，通常都遵循“集中读写”的原则，使用一些数据，大概率会使用附近的数据，这就是所谓的“局部性原理”，它表明提前加载是有效的，确实能够减少磁盘IO。 </p>
<p><strong>按页(4K)读取，和InnoDB的缓冲池设计有啥关系？</strong>（1）磁盘访问按页读取能够提高性能，所以缓冲池一般也是按页缓存数据；（2）预读机制启示了我们，能把一些“可能要访问”的页提前加入缓冲池，避免未来的磁盘IO操作；</p>
<p><strong>InnoDB是以什么算法，来管理这些缓冲页呢？</strong>最容易想到的，就是LRU(Least recently used)。</p>
<p><strong>传统的LRU是如何进行缓冲页管理？</strong>最常见的玩法是，把入缓冲池的页放到LRU的头部，作为最近访问的元素，从而最晚被淘汰。这里又分两种情况：（1）<strong>页已经在缓冲池里</strong>，那就只做“移至”LRU头部的动作，而没有页被淘汰；（2）<strong>页不在缓冲池里</strong>，除了做“放入”LRU头部的动作，还要做“淘汰”LRU尾部页的动作；</p>
<p>虽然传统的LRU缓冲池算法十分直观，但这里有两个问题：（1）<strong>预读失效</strong>；（2）<strong>缓冲池污染</strong></p>
<p><strong>什么是预读失效？</strong>由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效。</p>
<p><strong>如何对预读失效进行优化？</strong>要优化预读失效，思路是：（1）让预读失败的页，停留在缓冲池LRU里的时间尽可能短；（2）让真正被读取的页，才挪到缓冲池LRU的头部；以保证，真正被读取的热数据留在缓冲池里的时间尽可能长。</p>
<p><strong>具体方法是</strong>：</p>
<ol>
<li>将LRU分为两个部分：新生代(new sublist)老生代(old sublist)</li>
<li>新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)</li>
<li>新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：如果数据真正被读取（预读成功），才会加入到新生代的头部如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池</li>
</ol>
<p><strong>举个例子，整个缓冲池LRU如图：</strong></p>
<p>（1）整个LRU长度是10（2）前70%是新生代（3）后30%是老生代（4）新老生代首尾相连</p>
<img src="/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/Image.png" alt="Image" style="zoom: 95%;">

<p>假如有一个页号为50的新页被预读加入缓冲池：</p>
<ol>
<li>50只会从老生代头部插入，老生代尾部（也是整体尾部）的页会被淘汰掉；</li>
<li>假设50这一页不会被真正读取，即预读失败，它将比新生代的数据更早淘汰出缓冲池；</li>
</ol>
<img src="/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/Image-1594741614324.png" alt="Image" style="zoom:95%;">

<p>假如50这一页立刻被读取到，例如SQL访问了页内的行row数据：</p>
<ol>
<li>它会被立刻加入到新生代的头部；</li>
<li>新生代的页会被挤到老生代，此时并不会有页面被真正淘汰；</li>
</ol>
<img src="/2020/03/20/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0/Image-1594747637932.png" alt="Image" style="zoom:95%;">

<p><strong>老生代改进版LRU仍然解决不了缓冲池污染的问题。</strong></p>
<p><strong>什么是MySQL缓冲池污染？</strong></p>
<p>当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。 </p>
<p>例如，有一个数据量较大的用户表，当执行：select * from user where name like “%foo%”，虽然结果集可能只有少量数据，但这类like不能命中索引，必须全表扫描，就需要访问大量的页：</p>
<ol>
<li>把页加到缓冲池（插入老生代头部）；</li>
<li>从页里读出相关的row（插入新生代头部）；</li>
<li>row里的name字段和字符串foo进行比较，如果符合条件，加入到结果集中；</li>
<li>直到扫描完所有页中的所有row</li>
</ol>
<p>如此一来，所有的数据页都会被加载到新生代的头部，但只会访问一次，真正的热数据被大量换出。</p>
<p><strong>怎么处理这类扫码大量数据导致的缓冲池污染问题呢？</strong></p>
<p>MySQL缓冲池加入了一个“<strong>老生代停留时间窗口</strong>”的机制：</p>
<ol>
<li>假设T=老生代停留时间窗口；</li>
<li>插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部</li>
<li>只有满足“<strong>被访问”</strong>并且“<strong>在老生代停留时间”大于T</strong>，才会被放入新生代头部；</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li>缓冲池(buffer pool)是一种<strong>常见的降低磁盘访问的机制；</strong></li>
<li>缓冲池通常<strong>以页(page)为单位缓存数据</strong>；</li>
<li>缓冲池的<strong>常见管理算法是LRU</strong>，memcache，OS，InnoDB都使用了这种算法；</li>
<li>InnoDB对普通LRU进行了优化：<ul>
<li>将缓冲池分为<strong>老生代和新生代</strong>，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，<strong>以解决预读失效的问题</strong></li>
<li><strong>页被访问</strong>，且在老生代<strong>停留时间超过配置阈值</strong>的，才进入新生代，<strong>以解决批量数据访问，大量热数据淘汰的问题</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>前置++和后置++</title>
    <url>/2020/03/07/%E5%89%8D%E7%BD%AE++%E5%92%8C%E5%90%8E%E7%BD%AE++/</url>
    <content><![CDATA[<p>++a表示取a的地址，增加它的内容，然后把值放在寄存器中；</p>
<p>a++表示取a的地址，把它的值装入寄存器，然后增加内存中的a的值；</p>
<p><strong>前置++和后置++的重载</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Age &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Age <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        Age tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Age a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码，我们可以看出前置++和后置++，有4点不同：</p>
<ol>
<li>返回类型不同</li>
<li>形参不同</li>
<li>代码不同</li>
<li>效率不同</li>
</ol>
<p><strong>1. 返回值类型的区别</strong></p>
<p>前置++的返回类型是Age&amp;，后置++的返回类型const Age。这意味着，前置++返回的是左值，后置++返回的是右值</p>
<p>左值和右值，决定了前置++和后置++的用法</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">int</span> <span class="comment">main()</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">Age</span> <span class="comment">a;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span>    <span class="comment">(a</span>++<span class="comment">)</span>++<span class="comment">;</span>  <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment"></span>    ++<span class="comment">(a</span>++<span class="comment">);</span>  <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">a</span>++ <span class="comment">=</span> <span class="comment">1;</span>   <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">(</span>++<span class="comment">a)</span>++<span class="comment">;</span>  <span class="comment">//OK</span></span><br><span class="line"><span class="comment"></span>    ++<span class="comment">(</span>++<span class="comment">a);</span>  <span class="comment">//OK</span></span><br><span class="line"><span class="comment"></span>    ++<span class="comment">a</span> <span class="comment">=</span> <span class="comment">1;</span>   <span class="comment">//OK</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<p>++的类型是const Age，自然不能对它进行前置++、后置++、赋值等操作。</p>
<p>++a的类型是Age&amp;，当然可以对它进行前置++、后置++、赋值等操作</p>
<p><strong>a++的返回类型为什么要是const对象呢？</strong></p>
<p>对于内置类型，(i++)++这样的表达式是不能通过编译的。自定义类型的操作符重载，应该与内置类型保持行为一致</p>
<p><strong>2. 形参不同</strong></p>
<p>前置++没有形参，而后置++有一个int形参</p>
<p><strong>3.代码实现的区别</strong></p>
<p>前置++的实现比较简单，自增之后，将<em>this返回即可。需要注意的是，一定要返回</em>this。</p>
<p>后置++的实现稍微麻烦一些。因为要返回自增之前的对象，所以先将对象拷贝一份，再进行自增，最后返回那个拷贝</p>
<p><strong>4.效率的区别</strong></p>
<p>前置++的效率更高，理由是：后置++会生成临时对象</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>指针、数组和函数</title>
    <url>/2020/02/11/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>数组指针和指针数组</strong></p>
<p><strong>数组指针</strong></p>
<p>定义 int (*p)[n];</p>
<p>()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度</p>
<p>如要将二维数组赋给一指针，应这样赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>]; <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组。</span></span><br><span class="line">p=a;        <span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span></span><br><span class="line">p++;       <span class="comment">//该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span></span><br></pre></td></tr></table></figure>

<p><strong>指针数组</strong></p>
<p>定义 int *p[n];</p>
<p>[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值</p>
<p>如要将二维数组赋给一指针数组:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	p[i]=a[i];</span><br></pre></td></tr></table></figure>

<p>这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]，所以要分别赋值</p>
<p><strong>指针数组和数组指针的内存布局</strong></p>
<img src="/2020/02/11/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/22201218-19ddd896ae6a45e1b61c7e3ee59b4662.jpg" alt="img" style="zoom: 80%;">

<hr>
<p><strong>函数指针和指针函数</strong></p>
<p><strong>指针函数</strong></p>
<p>指针函数，简单的来说，就是一个<strong>返回指针</strong>的函数，其本质是一个函数，而该函数的返回值是一个指针。<br>声明格式为：<strong>类型标识符 *函数名(参数表)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        sum = a + b;</span><br><span class="line">        <span class="keyword">return</span> &amp;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">        p=add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add result is %d\n"</span>, *p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数指针</strong></p>
<p>函数指针，其本质是一个<strong>指针变量</strong>，该<strong>指针指向这个函数</strong>。总结来说，函数指针就是指向函数的指针。<br>声明格式：类型说明符  (*函数名)  (参数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br></pre></td></tr></table></figure>

<p>函数指针是需要把一个函数的地址赋值给它，有两种写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure>

<p>调用函数指针的方式也有两种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        p=add;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add result is %d\n"</span>, p(<span class="number">200</span>,<span class="number">300</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>一种string类的简单实现</title>
    <url>/2020/01/20/%E4%B8%80%E7%A7%8Dstring%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>C++中String类的简单实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    myString(<span class="keyword">const</span> <span class="keyword">char</span> *str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *data = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    myString(<span class="keyword">const</span> myString &amp;str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    myString(myString&amp;&amp; str):data(str.data)&#123;</span><br><span class="line">        str.data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">    myString &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> myString &amp;str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">    myString&amp; <span class="keyword">operator</span>=(myString&amp;&amp; str)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = str.data;</span><br><span class="line">        str.data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~myString()&#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">String</span> s0; <span class="comment">//构造</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>; <span class="comment">//构造</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">s2</span><span class="params">(s0)</span></span>;</span><br><span class="line">    <span class="keyword">String</span> s3 = s1;</span><br><span class="line">    s2 = s1;</span><br><span class="line"></span><br><span class="line">    foo(s1);</span><br><span class="line">    bar(s1);</span><br><span class="line">    foo(<span class="string">"temporary"</span>);</span><br><span class="line">    bar(<span class="string">"temporary"</span>);</span><br><span class="line">    <span class="keyword">String</span> s4 = baz();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">String</span>&gt; svec;</span><br><span class="line">    svec.push_back(s0);</span><br><span class="line">    svec.push_back(s1);</span><br><span class="line">    svec.push_back(baz());</span><br><span class="line">    svec.push_back(<span class="string">"good job"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝赋值</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">移动构造</span><br><span class="line">拷贝构造</span><br><span class="line">拷贝构造</span><br><span class="line">构造</span><br><span class="line">移动构造</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确地删除vector中符合条件的某元素</title>
    <url>/2019/11/20/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%88%A0%E9%99%A4vector%E4%B8%AD%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9F%90%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>比如，有一个vector&lt; int &gt; nums = {1, 2, 2, 2, 2, 3, 5}，要求删除nums中所有值为2的元素 </p>
<h3 id="一个符合直觉的错误实现"><a href="#一个符合直觉的错误实现" class="headerlink" title="一个符合直觉的错误实现"></a>一个符合直觉的错误实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123; </span><br><span class="line">        nums.erase(it); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码循环遍历nums中的每个元素，判断是否为2，是的话则erase掉。看起来好像没什么问题，但是实际上已经造成了bug。这段代码的执行完成后，<strong>nums存储的元素是{1, 2, 2, 3, 5}</strong>，值为2的元素并没有被全部清除掉。</p>
<p>为什么会出现这个结果呢？原因就是<strong>迭代器失效</strong> ：在第一个2被erase掉的时候，it迭代器已经失效了，它指向了被删除元素的下一个元素，用它来继续遍历vector就会漏掉被删除元素后面的第一个元素，导致2没有被完全清除。</p>
<h3 id="第一种正确实现：让it指向下一个元素"><a href="#第一种正确实现：让it指向下一个元素" class="headerlink" title="第一种正确实现：让it指向下一个元素"></a>第一种正确实现：让it指向下一个元素</h3><p><strong>erase函数的返回值是指向当前被删除元素的下一个元素的迭代器</strong>。那么我们把这个返回值赋值给it继续遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">        it = nums.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种正确实现：erase-remove"><a href="#第二种正确实现：erase-remove" class="headerlink" title="第二种正确实现：erase-remove"></a>第二种正确实现：erase-remove</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    nums.erase(<span class="built_in">remove</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(), <span class="number">2</span>), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>erase</strong>用来删除一段区间的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>remove</strong>  <strong>移除但不删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它<strong>并不真正从容器中删除那些元素</strong>（换句话说容器的大小不变），<strong>而是将每一个不与value相等（也就是我们不打算移除）的元素轮番赋值给first之后的空间</strong>。</p>
<p>例如：{0，1，0，2，0，3，0，4}，用remove移除值为0的元素，执行结果为{1，2，3，4，0，3，0，4}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>) &#123;</span></span><br><span class="line">    first = <span class="built_in">find</span>(first, last, value);</span><br><span class="line">    ForwardIterator next = first;</span><br><span class="line">    <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> remove_copy(++next, last, first, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove_copy</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">IntputIt</span> <span class="title">first</span>,<span class="title">IntputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br></pre></td></tr></table></figure>

<p>remove移除[first, last)之中所有与value相等的元素，它并不真正从容器中删除那些元素（换句话说容器的大小不变）,而是<strong>将结果复制到一个以result标示起始位置的容器上，新容器可以和原容器重叠。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">OutputIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIt</span> <span class="title">remove_copy</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">OutputIt</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first!=last;++first)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*first!=value)&#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









































]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C库函数memcpy()和memmove()的区别</title>
    <url>/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>memcpy( )和memmove( )都是C语言中的库函数，在头文件string.h中。</p>
<p>其作用是从src内存中拷贝n个字节到dest内存区域中，原型分别如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="memcpy-和memmove-的区别"><a href="#memcpy-和memmove-的区别" class="headerlink" title="memcpy()和memmove()的区别"></a>memcpy()和memmove()的区别</h3><p>他们的作用是一样的，<strong>唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。</strong></p>
<p><img src="/2019/11/19/memcpy()%E5%92%8Cmemmove()%E7%9A%84%E5%8C%BA%E5%88%AB/memory.png" alt="memory"></p>
<h3 id="memcpy-函数的实现"><a href="#memcpy-函数的实现" class="headerlink" title="memcpy()函数的实现"></a>memcpy()函数的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    <span class="keyword">char</span> *s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        *tmp++ = *s_src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="memmove-实现函数"><a href="#memmove-实现函数" class="headerlink" title="memmove()实现函数"></a>memmove()实现函数</h3><p>memmove就是针对第二种内存覆盖情形，对memcpy进行了改进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memmove</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s_dst;</span><br><span class="line">    <span class="keyword">char</span>* s_src;</span><br><span class="line">    s_dst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">    s_src = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">if</span>(s_dst&gt;s_src &amp;&amp; (s_src+n&gt;s_dst)) &#123;      <span class="comment">//第二种内存覆盖的情形。</span></span><br><span class="line">        <span class="comment">// 从后往前复制，防止出现内存覆盖的情形</span></span><br><span class="line">        s_dst = s_dst+n<span class="number">-1</span>;</span><br><span class="line">        s_src = s_src+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst-- = *s_src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            *s_dst++ = *s_src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>MFCC特征提取</title>
    <url>/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h3 id="MFCC特征提取流程"><a href="#MFCC特征提取流程" class="headerlink" title="MFCC特征提取流程"></a>MFCC特征提取流程</h3><img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image.png" alt="Image" style="zoom:80%;">

<h3 id="预加重（Pre-emphasis）"><a href="#预加重（Pre-emphasis）" class="headerlink" title="预加重（Pre-emphasis）"></a>预加重（Pre-emphasis）</h3><p>语音中有频谱倾斜（Spectral Tilt）现象，即低频具有较高能量， 因此，需要加重高频语音的能量，使得高频信息凸显出来（与低频相比，预加重增加了语音信号中高频的幅度）其计算方法 ：      <img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900551638.png" alt="img"></p>
<p>x(t) 表示音频数据（可以看成一个向量）的第 t 个数，α 通常取值范围是 (0.95,0.99)</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900551638.png" alt="img" style="zoom:80%;">

<p>python代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_emphasis</span><span class="params">(signal, coeff=<span class="number">0.95</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> numpy.append(signal[<span class="number">0</span>], signal[<span class="number">1</span>:] - coeff * signal[:<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="分帧加窗（Framing-Windowing）"><a href="#分帧加窗（Framing-Windowing）" class="headerlink" title="分帧加窗（Framing-Windowing）"></a>分帧加窗（Framing-Windowing）</h3><p>特征提取时，如果每次取出 25 ms（跨度） 的语音，进行离散傅里叶变换计算出一帧，接着步移 10 ms 继续计算下一帧，这种基本做法就是矩形（Rectangular Window），棱角分明的窗容易造成<strong>频谱泄露</strong>（Spectral Leakage）， 可以选择使用钟形窗，如海明窗（Hamming Window）、 汉宁窗（Hanning Window）等。加窗的计算方法：</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900607629.png" alt="Image" style="zoom:80%;">

<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900785096.png" alt="Image" style="zoom: 67%;">

<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900800816.png" alt="Image" style="zoom:67%;">

<p><strong>python代码实现：</strong></p>
<p>实现分帧加窗</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">framesig</span><span class="params">(sig, frame_len, frame_step, winfunc=lambda x: numpy.ones<span class="params">(<span class="params">(x,)</span>)</span>, stride_trick=True)</span>:</span></span><br><span class="line"><span class="string">"""Frame a signal into overlapping frames.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:param sig: the audio signal to frame.</span></span><br><span class="line"><span class="string">:param frame_len: length of each frame measured in samples.</span></span><br><span class="line"><span class="string">:param frame_step: number of samples after the start of the previous frame that the next frame should begin.</span></span><br><span class="line"><span class="string">:param winfunc: the analysis window to apply to each frame. By default no window is applied.</span></span><br><span class="line"><span class="string">:param stride_trick: use stride trick to compute the rolling window and window multiplication faster</span></span><br><span class="line"><span class="string">:returns: an array of frames. Size is NUMFRAMES by frame_len.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    slen = len(sig)</span><br><span class="line">    <span class="comment"># 对帧长和步长取整</span></span><br><span class="line">    frame_len = int(round_half_up(frame_len))</span><br><span class="line">    frame_step = int(round_half_up(frame_step))</span><br><span class="line">    <span class="comment"># 计算帧数</span></span><br><span class="line">    <span class="keyword">if</span> slen &lt;= frame_len:</span><br><span class="line">        numframes = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        numframes = <span class="number">1</span> + int(math.ceil((<span class="number">1.0</span> * slen - frame_len) /frame_step))</span><br><span class="line">    <span class="comment"># 分帧后如果最后剩余的长度不够一帧，将所需的长度填充为零，连接到原始信号的后 面，算作一帧</span></span><br><span class="line">    padlen = int((numframes - <span class="number">1</span>) * frame_step + frame_len)</span><br><span class="line">    zeros = numpy.zeros((padlen - slen,))</span><br><span class="line">    padsignal = numpy.concatenate((sig, zeros))</span><br><span class="line">    <span class="comment"># 使用技巧加窗</span></span><br><span class="line">    <span class="keyword">if</span> stride_trick:</span><br><span class="line">    win = winfunc(frame_len)</span><br><span class="line">    frames = rolling_window(padsignal, window=frame_len, step=frame_step)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 不使用技巧</span></span><br><span class="line">    indices = numpy.tile(numpy.arange(<span class="number">0</span>, frame_len), (numframes, <span class="number">1</span>)) +   numpy.tile(numpy.arange(<span class="number">0</span>, numframes * frame_step, frame_step), (frame_len, <span class="number">1</span>)).T</span><br><span class="line">    indices = numpy.array(indices, dtype=numpy.int32)</span><br><span class="line">    frames = padsignal[indices]</span><br><span class="line">    win = numpy.tile(winfunc(frame_len), (numframes, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frames * win</span><br></pre></td></tr></table></figure>

<h3 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h3><p>DFT 从每一段加窗后的音频中分别提取出频域信息，计算方式为： </p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900876513.png" alt="Image" style="zoom: 50%;">

<p>其中xi为第i个长度为N的帧，K为DFT的长度（<strong>DFT 的一个实现方法是快速傅里叶变换（Fast Fourier Transform，FFT）， 可将时间复杂度从 O(N*N) 降为 O(Nlog2N)，但需要保证窗长 N 是 2 的指数，如果原窗长不满足此条件，一般音频信号 x 补充尾零，如 400 的窗长可扩展为 512)通过复数 X(k) 可计算第 k 个频段的幅度（Magnitude）和相位（Phase）</strong>，幅度之于频率的坐标图即是频谱（Spectrum）频谱的具体使用中，通常用 <img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image(3).png" alt="img" style="zoom:50%;">表示第 k 个频段的能量值（忽略了相位信息），记为 Power Spectrum（既是能量频谱，也是频谱的幂），并根据奈奎斯特频率（NyquistFrequency），只取其前半段（比如 512 的频数，取其前 512∗1/2+1）作为最终输出结果</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900936392.png" alt="Image" style="zoom:50%;">

<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601900966423.png" alt="Image" style="zoom:67%;">

<p>python代码实现<br><strong>傅里叶变换长度NFFT的计算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_nfft</span><span class="params">(samplerate, winlen)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param samplerate: The sample rate of the signal we are working with, in Hz.</span></span><br><span class="line"><span class="string">    :param winlen: The length of the analysis window in seconds.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    window_length_samples = winlen * samplerate</span><br><span class="line">    nfft = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> nfft &lt; window_length_samples:</span><br><span class="line">    nfft *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nfft</span><br></pre></td></tr></table></figure>

<p><strong>计算帧中每帧的幅度值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">magspec</span><span class="params">(frames, NFFT)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param frames: the array of frames. Each row is a frame.</span></span><br><span class="line"><span class="string">    :param NFFT: the FFT length to use. If NFFT &gt; frame_len, the frames are zero-padded.</span></span><br><span class="line"><span class="string">    :returns: If frames is an NxD matrix, output will be Nx(NFFT/2+1).</span></span><br><span class="line"><span class="string">    Each row will be the magnitude spectrum of the corresponding frame.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> numpy.shape(frames)[<span class="number">1</span>] &gt; NFFT:</span><br><span class="line">    logging.warning(</span><br><span class="line">    <span class="string">'frame length (%d) is greater than FFT size (%d), frame will be truncated. Increase NFFT to avoid.'</span>,</span><br><span class="line">    numpy.shape(frames)[<span class="number">1</span>], NFFT)</span><br><span class="line">    complex_spec = numpy.fft.rfft(frames, NFFT)</span><br><span class="line">    <span class="keyword">return</span> numpy.absolute(complex_spec)</span><br></pre></td></tr></table></figure>

<p><strong>计算帧中每帧的功率谱</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powspec</span><span class="params">(frames, NFFT)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">:param frames: the array of frames. Each row is a frame.</span></span><br><span class="line"><span class="string">:param NFFT: the FFT length to use. If NFFT &gt; frame_len, the frames are zero-padded.</span></span><br><span class="line"><span class="string">:returns: If frames is an NxD matrix, output will be Nx(NFFT/2+1).</span></span><br><span class="line"><span class="string">Each row will be the power spectrum of the corresponding frame.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / NFFT * numpy.square(magspec(frames, NFFT))</span><br></pre></td></tr></table></figure>

<h3 id="梅尔滤波器组-Mel-Filter-Bank"><a href="#梅尔滤波器组-Mel-Filter-Bank" class="headerlink" title="梅尔滤波器组(Mel Filter Bank)"></a>梅尔滤波器组(Mel Filter Bank)</h3><p>人耳对不同频率的感知程度不一样，频率越高，敏感度较低，所以人耳的频域感知是非线性的，梅尔刻度（Mel Scale）正是刻画这种规律的， 它反映了人耳线性感知的梅尔频率（Mel Frequency） 与一般频率之间的关系。由一般频率 f 到梅尔刻度 Mel( f )的换算公式为：</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601901056718.png" alt="Image" style="zoom:67%;">

<p>梅尔刻度 Mel( f )到一般频率 f 的换算公式为：</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601901068825.png" alt="Image" style="zoom: 67%;">

<p>将频谱规划到梅尔刻度上，能有效促进语音识别系统的性能，实现方法是梅尔滤波器组（Mel Filter Bank）。 将上一部分输出的能量频谱通过如下图所示的三角滤波器组（Triangular Filter Bank） 得到梅尔频谱，计算方式与加窗类似，越往高频，滤波器窗口越大，窗口扩大的量级则与梅尔刻度一致。滤波器的个数就是梅尔频段的总数目，通常取为几十。梅尔频谱的能量数值取对数，最终得到的结果就是常说的 FBANK 特征。对数计算增强了特征的鲁棒性，且人类对能量强弱的感知是符合对数关系的。用于 DNN 训练时，FBANK 的维度就是梅尔滤波器的个数，常取 20 到 40 之间。     </p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601901086633.png" alt="Image" style="zoom:67%;">

<p>python代码实现</p>
<p><strong>将频率Hz转换为梅尔刻度mel</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hz2mel</span><span class="params">(hz)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2595</span> * numpy.log10(<span class="number">1</span> + hz / <span class="number">700.</span>)</span><br></pre></td></tr></table></figure>

<p><strong>将梅尔刻度mel转换为频率Hz</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mel2hz</span><span class="params">(mel)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">700</span> * (<span class="number">10</span> ** (mel / <span class="number">2595.0</span>) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>计算梅尔滤波器组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_filterbanks</span><span class="params">(nfilt=<span class="number">26</span>, nfft=<span class="number">512</span>, samplerate=<span class="number">16000</span>, lowfreq=<span class="number">0</span>, highfreq=None)</span>:</span></span><br><span class="line">    <span class="string">"""Compute a Mel-filterbank. The filters are stored in the rows, the columns correspond</span></span><br><span class="line"><span class="string">    to fft bins. </span></span><br><span class="line"><span class="string">    :param nfilt: the number of filters in the filterbank, default 20.</span></span><br><span class="line"><span class="string">    :param nfft: the FFT size. Default is 512.</span></span><br><span class="line"><span class="string">    :param samplerate: the sample rate of the signal we are working with, in Hz. Affects mel spacing.</span></span><br><span class="line"><span class="string">    :param lowfreq: lowest band edge of mel filters, default 0 Hz</span></span><br><span class="line"><span class="string">    :param highfreq: highest band edge of mel filters, default samplerate/2</span></span><br><span class="line"><span class="string">    :returns: A numpy array of size nfilt * (nfft/2 + 1) containing filterbank. Each row holds 1 filter.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 最高频率的计算</span></span><br><span class="line">    highfreq = highfreq <span class="keyword">or</span> samplerate / <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> highfreq &lt;= samplerate / <span class="number">2</span>, <span class="string">"highfreq is greater than samplerate/2"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute points evenly spaced in mels</span></span><br><span class="line">    lowmel = hz2mel(lowfreq)</span><br><span class="line">    highmel = hz2mel(highfreq)</span><br><span class="line">    <span class="comment"># 在时域中算出每个滤波器所对应的频率点</span></span><br><span class="line">    melpoints = numpy.linspace(lowmel, highmel, nfilt + <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 将频率舍入到最近的FFT区间</span></span><br><span class="line">    bin = numpy.floor((nfft + <span class="number">1</span>) * mel2hz(melpoints) / samplerate)</span><br><span class="line"></span><br><span class="line">    fbank = numpy.zeros([nfilt, nfft // <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, nfilt):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(bin[j]), int(bin[j + <span class="number">1</span>])):</span><br><span class="line">    fbank[j, i] = (i - bin[j]) / (bin[j + <span class="number">1</span>] - bin[j])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(bin[j + <span class="number">1</span>]), int(bin[j + <span class="number">2</span>])):</span><br><span class="line">    fbank[j, i] = (bin[j + <span class="number">2</span>] - i) / (bin[j + <span class="number">2</span>] - bin[j + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fbank</span><br></pre></td></tr></table></figure>

<h3 id="对数运算（log）、离散余弦变换（DCT）和升倒谱运算（lifter）"><a href="#对数运算（log）、离散余弦变换（DCT）和升倒谱运算（lifter）" class="headerlink" title="对数运算（log）、离散余弦变换（DCT）和升倒谱运算（lifter）"></a>对数运算（log）、离散余弦变换（DCT）和升倒谱运算（lifter）</h3><p>对上一部得到的feat（这也是由人类听觉引起的:我们听不到线性尺度上的响度。一般来说，要使一个声音的感知音量翻倍，我们需要投入8倍的能量。这意味着，如果一开始声音就很大，那么能量的巨大变化可能听起来并没有那么大的不同。这种压缩操作使我们的特性与人类实际听到的更接近。为什么是对数而不是立方根?对数允许我们使用倒谱平均减法，这是一种信道归一化技术）</p>
<p>接着对26个对数滤波器组feat进行离散余弦变换(DCT)得到26个倒谱系数，并且每一帧只保留前13个数据，每帧的这13个数称为梅尔倒谱系数（Mel Frequency Cepstral Coefficients）（因为我们的滤波器组都是重叠的，所以滤波器组能量彼此非常相关。 DCT可以对能量进行去相关，将包络与谐波分开）</p>
<p>最后进行升倒谱运算。默认升倒谱系数为22，这个过程做法是先产生一个拥有13个元素的一维数组llift，这13个元素的值lift[i]=1+(22 /2)<em>sin(pi</em>i/22)。得到这个数组lift之后，将上一步的feat和lift进行矩阵乘法，这其实就是mfcc参数的第一组。如果这组参数想要加上能量作为其表示方式，可以把每一行的的第一个元素numpy.log(energy)的每个值替换，即L[i][0] = F[i]。</p>
<p>python代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feat = numpy.log(feat)</span><br><span class="line">feat = dct(feat, type=<span class="number">2</span>, axis=<span class="number">1</span>, norm=<span class="string">'ortho'</span>)[:, :numcep] <span class="comment"># 封装好的DCT函数</span></span><br><span class="line">feat = lifter(feat, ceplifter)</span><br><span class="line"><span class="keyword">if</span> appendEnergy:</span><br><span class="line">    feat[:, <span class="number">0</span>] = numpy.log(energy)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lifter</span><span class="params">(cepstra, L=<span class="number">22</span>)</span>:</span></span><br><span class="line">    <span class="string">""" This has the effect of increasing the magnitude of the high frequency DCT coeffs.</span></span><br><span class="line"><span class="string">    :param cepstra: the matrix of mel-cepstra, will be numframes * numcep in size.</span></span><br><span class="line"><span class="string">    :param L: the liftering coefficient to use. Default is 22. L &lt;= 0 disables lifter.</span></span><br><span class="line"><span class="string">    """</span>    </span><br><span class="line">    <span class="keyword">if</span> L &gt; <span class="number">0</span>:</span><br><span class="line">        nframes, ncoeff = numpy.shape(cepstra)</span><br><span class="line">        n = numpy.arange(ncoeff)</span><br><span class="line">        lift = <span class="number">1</span> + (L / <span class="number">2.</span>) * numpy.sin(numpy.pi * n / L)</span><br><span class="line">        <span class="keyword">return</span> lift * cepstra</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># values of L &lt;= 0, do nothing</span></span><br><span class="line">        <span class="keyword">return</span> cepstra</span><br></pre></td></tr></table></figure>

<p>由此得到了MFCC的第一组特征参数</p>
<h3 id="计算动态特征（dynamic-feature）：Deltas-and-Delta-Deltas"><a href="#计算动态特征（dynamic-feature）：Deltas-and-Delta-Deltas" class="headerlink" title="计算动态特征（dynamic feature）：Deltas and Delta-Deltas"></a>计算动态特征（dynamic feature）：Deltas and Delta-Deltas</h3><p>（即MFCC的第二组和第三组特征参数）</p>
<p>MFCC特征向量只描述单个帧的功率谱包络线，但似乎语音也具有动态信息，即MFCC系数随时间的轨迹。结果表明，计算MFCC轨迹并将其附加到原始特征向量上可以大大提高ASR性能(如果我们有13个MFCC系数，我们还会得到13个deltas系数和13个delta-deltas系数，这将结合起来得到长度为39的特征向量)为了计算delta系数，使用以下公式：</p>
<img src="/2019/10/11/MFCC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/Image-1601901287830.png" alt="Image" style="zoom:67%;">

<p>其中dt为一个delta系数，c<em>t</em> 为上一步得到的第一组MFCC特征参数中的系数，N一般取2。Delta-Deltas系数的计算方法是一样的，但它们是由Deltas来计算的</p>
<p>python实现Deltas</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delta</span><span class="params">(feat, N)</span>:</span></span><br><span class="line">    <span class="string">"""Compute delta features from a feature vector sequence.</span></span><br><span class="line"><span class="string">    :param feat: A numpy array of size (NUMFRAMES by number of features) containing features.</span></span><br><span class="line"><span class="string">    Each row holds 1 feature vector.</span></span><br><span class="line"><span class="string">    :param N: For each frame, calculate delta features based on preceding and following N frames</span></span><br><span class="line"><span class="string">    :returns: A numpy array of size (NUMFRAMES by number of features) containing delta features.</span></span><br><span class="line"><span class="string">    Each row holds 1 delta feature vector.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> N &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'N must be an integer &gt;= 1'</span>)</span><br><span class="line">    NUMFRAMES = len(feat)</span><br><span class="line">    <span class="comment"># print(NUMFRAMES)</span></span><br><span class="line">    denominator = <span class="number">2</span> * sum([i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>)])</span><br><span class="line">    delta_feat = numpy.empty_like(feat)</span><br><span class="line">    padded = numpy.pad(feat, ((N, N), (<span class="number">0</span>, <span class="number">0</span>)), mode=<span class="string">'edge'</span>) <span class="comment"># padded version of feat</span></span><br><span class="line">    print(<span class="string">"padded的维度："</span>, end=<span class="string">""</span>)</span><br><span class="line">    print(padded.shape)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(NUMFRAMES):</span><br><span class="line">        <span class="comment"># [t : t+2*N+1] == [(N+t)-N : (N+t)+N+1]</span></span><br><span class="line">        delta_feat[t] = numpy.dot(numpy.arange(-N, N + <span class="number">1</span>),</span><br><span class="line">        padded[(N + t) - N: (N + t) + N + <span class="number">1</span>]) / denominator</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delta_feat</span><br></pre></td></tr></table></figure>

<p>以上得到了MFCC的第二组和第三组特征参数</p>
]]></content>
      <categories>
        <category>语音信号</category>
      </categories>
      <tags>
        <tag>语音信号</tag>
      </tags>
  </entry>
  <entry>
    <title>音频信号分帧</title>
    <url>/2019/10/05/%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%88%86%E5%B8%A7/</url>
    <content><![CDATA[<p>什么是分帧？通俗地理解就是，<strong>加窗处理</strong>、<strong>分段处理</strong>。随着窗口的往右（假设向右代表时间向前）推移，对加窗后的信号逐步展开处理。</p>
<p><strong>分帧的三个要素</strong>：</p>
<ol>
<li><p>窗口长度是多少wlen（window length）。(帧长一般取为 20 ~ 50 毫秒)</p>
</li>
<li><p>每次窗口往右移动多长，即增量increment，或步长step。(常见的取法是取为帧长的一半，或者固定取为 10 毫秒)</p>
</li>
<li><p>窗口选什么类型。时域上的加窗就是把原始信号x(t)与窗口w(t)相乘，频域就是对应的卷积。 不同的窗函数有不同的性质。常见的有矩形窗、三角窗、Hanning窗、<strong>Hamming窗</strong>、Blackman窗、Kaiser窗 …… (加窗的目的是让一帧信号的幅度在两端渐变到 0。渐变对傅里叶变换有好处，可以提高变换结果（即频谱）的分辨率)</p>
<p><img src="/2019/10/05/%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%88%86%E5%B8%A7/v2-29273fde835815754c6e7369f463aa10_hd.jpg" alt="v2-29273fde835815754c6e7369f463aa10_hd"></p>
</li>
</ol>
<p>对一帧信号做傅里叶变换，得到的结果叫<strong>频谱</strong></p>
<p><img src="/2019/10/05/%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E5%88%86%E5%B8%A7/v2-05197addda7c2019a388f5b7e9e94f04_r.jpg" alt="v2-05197addda7c2019a388f5b7e9e94f04_r"></p>
<p>语音的频谱，常常呈现出「<strong>精细结构</strong>」和「<strong>包络</strong>」两种模式。「精细结构」就是蓝线上的一个个小峰，它们在横轴上的间距就是基频，它体现了语音的音高——峰越稀疏，基频越高，音高也越高。「包络」则是连接这些小峰峰顶的平滑曲线（红线），它代表了口型，即发的是哪个音。包络上的峰叫<strong>共振峰，</strong>图中能看出四个，分别在 500、1700、2450、3800 赫兹附近。</p>
<p><strong>代码实现</strong></p>
<p>帧数 Nframe = floor( (length(x) - wlen) / inc) + 1</p>
<p>x：原始音频型号，wlen：每一帧的长度，inc：相邻帧的间隔</p>
<p>MATLAB代码</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Nframe = <span class="built_in">floor</span>( (<span class="built_in">length</span>(x) - wlen) / inc) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:Nframe </span><br><span class="line">    idx = (<span class="number">1</span>:wlen) + (k<span class="number">-1</span>) * nstep;</span><br><span class="line">    x_frame = x(idx); </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>最后，分帧以后，应该把帧的序号对应上时间frame-to-time的函数如下:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">frameTime</span>=<span class="title">frame2time</span><span class="params">(frameNum,framelen,inc,fs)</span> </span></span><br><span class="line"><span class="comment">% 分帧后计算每帧对应的时间 </span></span><br><span class="line">frameTime=(((<span class="number">1</span>:frameNum)<span class="number">-1</span>)*inc+framelen/<span class="number">2</span>)/fs; <span class="comment">%fs为采样率</span></span><br></pre></td></tr></table></figure>

<p>而给定一个时刻，想求得其对应的帧的代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% t0 特定时刻 </span></span><br><span class="line">frame_idx=<span class="built_in">fix</span>((t0*fs-wlen)/nstep +<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>语音信号</category>
      </categories>
      <tags>
        <tag>语音信号</tag>
      </tags>
  </entry>
</search>
